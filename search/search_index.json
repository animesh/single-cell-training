{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Course website Material This website Zoom meeting (through mail) Google doc (through mail) Slack channel Learning outcomes General learning outcomes After this course, you will be able to: distinguish advantages and pitfalls of scRNAseq design your own scRNA-seq experiment apply a downstream analysis using R Learning outcomes explained To reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn. Learning experiences To reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only. Exercises Each block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we\u2019ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different. Asking questions During lectures, you are encouraged to raise your hand if you have questions (if in-person), or use the Zoom functionality (if online). Find the buttons in the participants list (\u2018Participants\u2019 button): Alternatively, (depending on your zoom version or OS) use the \u2018Reactions\u2019 button: A main source of communication will be our slack channel . Ask background questions that interest you personally at #background . During the exercises, e.g. if you are stuck or don\u2019t understand what is going on, use the slack channel #q-and-a . This channel is not only meant for asking questions but also for answering questions of other participants. If you are replying to a question, use the \u201creply in thread\u201d option: The teacher will review the answers, and add/modify if necessary. If you\u2019re really stuck and need specific tutor support, write the teachers or helpers personally. To summarise: During lectures: raise hand/zoom functionality Personal interest questions: #background During exercises: #q-and-a on slack","title":"Home"},{"location":"#course-website","text":"","title":"Course website"},{"location":"#material","text":"This website Zoom meeting (through mail) Google doc (through mail) Slack channel","title":"Material"},{"location":"#learning-outcomes","text":"","title":"Learning outcomes"},{"location":"#general-learning-outcomes","text":"After this course, you will be able to: distinguish advantages and pitfalls of scRNAseq design your own scRNA-seq experiment apply a downstream analysis using R","title":"General learning outcomes"},{"location":"#learning-outcomes-explained","text":"To reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn.","title":"Learning outcomes explained"},{"location":"#learning-experiences","text":"To reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only.","title":"Learning experiences"},{"location":"#exercises","text":"Each block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we\u2019ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different.","title":"Exercises"},{"location":"#asking-questions","text":"During lectures, you are encouraged to raise your hand if you have questions (if in-person), or use the Zoom functionality (if online). Find the buttons in the participants list (\u2018Participants\u2019 button): Alternatively, (depending on your zoom version or OS) use the \u2018Reactions\u2019 button: A main source of communication will be our slack channel . Ask background questions that interest you personally at #background . During the exercises, e.g. if you are stuck or don\u2019t understand what is going on, use the slack channel #q-and-a . This channel is not only meant for asking questions but also for answering questions of other participants. If you are replying to a question, use the \u201creply in thread\u201d option: The teacher will review the answers, and add/modify if necessary. If you\u2019re really stuck and need specific tutor support, write the teachers or helpers personally. To summarise: During lectures: raise hand/zoom functionality Personal interest questions: #background During exercises: #q-and-a on slack","title":"Asking questions"},{"location":"course_schedule/","text":"Day 1 block start end subject introduction 9:00 AM 9:30 AM Introduction block 1 9:30 AM 10:30 AM Introduction scRNAseq 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Introduction scRNAseq 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Normalization and scaling 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Quality control Day 2 block start end subject block 1 9:00 AM 10:30 AM Dimensionality reduction 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Integration 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Cell annotation 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Further exercises Day 3 block start end subject block 1 9:00 AM 10:30 AM Differential gene expression 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Differential gene expression 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Enrichment analysis 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Trajectory analysis","title":"Course schedule"},{"location":"course_schedule/#day-1","text":"block start end subject introduction 9:00 AM 9:30 AM Introduction block 1 9:30 AM 10:30 AM Introduction scRNAseq 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Introduction scRNAseq 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Normalization and scaling 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Quality control","title":"Day 1"},{"location":"course_schedule/#day-2","text":"block start end subject block 1 9:00 AM 10:30 AM Dimensionality reduction 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Integration 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Cell annotation 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Further exercises","title":"Day 2"},{"location":"course_schedule/#day-3","text":"block start end subject block 1 9:00 AM 10:30 AM Differential gene expression 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Differential gene expression 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Enrichment analysis 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:00 PM Trajectory analysis","title":"Day 3"},{"location":"precourse/","text":"Required competences Participants should already have a basic knowledge in Next Generation Sequencing (NGS) techniques, or have already followed the \u201cNGS - Quality control, Alignment, Visualisation\u201d. Knowledge in RNA sequencing is a plus. A basic knowledge of the R statistical software is required. Test your R skills with the quiz here , before registering. Software Attendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided, but attendees who wish to run the practicals on their own laptop should install R and RStudio, as well as install a range of R packages including Seurat, scran, scater, SingleR and monocle3, exact requirements will be communicated before the course.","title":"Precourse preparations"},{"location":"precourse/#required-competences","text":"Participants should already have a basic knowledge in Next Generation Sequencing (NGS) techniques, or have already followed the \u201cNGS - Quality control, Alignment, Visualisation\u201d. Knowledge in RNA sequencing is a plus. A basic knowledge of the R statistical software is required. Test your R skills with the quiz here , before registering.","title":"Required competences"},{"location":"precourse/#software","text":"Attendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided, but attendees who wish to run the practicals on their own laptop should install R and RStudio, as well as install a range of R packages including Seurat, scran, scater, SingleR and monocle3, exact requirements will be communicated before the course.","title":"Software"},{"location":"day1/general_introduction/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation","title":"General introduction"},{"location":"day1/general_introduction/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day1/general_introduction/#material","text":"Download the presentation","title":"Material"},{"location":"day1/introduction_scrnaseq/","text":"Learning outcomes After having completed this chapter you will be able to: Explain what kind of information single cell RNA-seq can give you to answer a biological question Describe essential considerations during the design of a single cell RNA-seq experiment Describe the pros and cons of different single cell sequencing methods Load single cell data into R Explain the basic structure of a Seurat object and extract count data and metadata Perform a basic quality control by: Evaluating the percentage of UMIs originating from mitochondrial genes Detecting doublets Material Download the presentation Seurat website Paper on experimental considerations Paper on experimental design SMART-seq3 protocol at protocols.io Exercises Login and set up Log in to Rstudio server with the provided link and password, your username is rstudio . First, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project\u2026 Continue by choosing New Directory As project type select New Project Finally, type in the project name. This should be single_cell_course . Finish by clicking Create Project . Now that we have setup a project and a project directory (it is in /home/rstudio/single_cell_course ), we can download the data that is required for this course. We will use the built-in terminal of Rstudio. To do this, select the Terminal tab: Downloading the course data To download and extract the dataset, copy-paste these commands inside the terminal tab: wget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/scRNAseq_v2.tar.gz tar -xvf scRNAseq_v2.tar.gz rm scRNAseq_v2.tar.gz Have a look at the data directory you have downloaded. It should contain the following: ./data \u251c\u2500\u2500 deng_dataset \u2502 \u2514\u2500\u2500 deng-reads.rds \u251c\u2500\u2500 gbm_dataset \u2502 \u251c\u2500\u2500 de_genes_gbm_res.0.2.csv \u2502 \u251c\u2500\u2500 dissocation_genes.txt \u2502 \u251c\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u2514\u2500\u2500 h.all.v7.2.symbols.xls \u2514\u2500\u2500 pancreas_dataset \u251c\u2500\u2500 pancreas_expression_matrix.rds \u2514\u2500\u2500 pancreas_metadata.rds Bug Add more information on origin of the data here We will be working with three different datasets: gbm_dataset : This will be our most used dataset, we will use it throughout the course pancreas_dataset : Pancreas cell dataset generated with four different methods. We will use it for integration and differential gene expression analysis deng_dataset : Cell development dataset, which we will use for trajectory analysis at day 3 Loading scRNAseq data This part uses the gbm dataset Today we will mainly work with the package Seurat . Load it into your environment like this: library ( Seurat ) To run through a typical Seurat analysis, we will use the files that are in the directory data/filtered_feature_bc_matrix . This directory is part of the output generated by cellranger . To load in this data into R and generate a sparse matrix, run the following command: gbm.data <- Seurat :: Read10X ( data.dir = \"data/gbm_dataset/filtered_feature_bc_matrix/\" ) Basically, this imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running: gbm.data [c ( \"PECAM1\" , \"CD8A\" , \"TSPAN1\" ), 1 : 30 ] To generate a Seurat object, we will run CreateSeuratObject . We choose to import only features (genes) that are expressed in at least 3 cells, and we include only cells that express 100 or more genes (features): gbm <- Seurat :: CreateSeuratObject ( counts = gbm.data , project = \"gbm\" , min.cells = 3 , min.features = 100 ) Function notation with :: Here, we define the function together with its associated package. We do that by the syntax package::function . Of course, you can also call library(package) , and only type the function name. Since we use many different packages in this course, it can be confusing which function comes from which package. Therefore, we chose to always associate the package with the called function. Exercise: check what\u2019s in the gbm object, by typing gbm in the R console. How many features are in there? And how many cells? Answer Typing gbm should return: An object of class Seurat 24363 features across 5553 samples within 1 assay Active assay: RNA (24363 features, 0 variable features) This means that we have 24363 genes (features) in there, and 5553 cells (samples) The Seurat object The gbm object we have created has the class Seurat . The object structure is rather complex, since it contains multi-level lists and slots. Exercise: A. Have a look at the gbm object by running str(gbm) . What is in there? Where in the object is the count data stored? B. Have a look at the data.frame stored at gbm@meta.data what kind of information is in there? Answer Answer A Running str(gbm) shows you that the object contains many slots with different classes. The count data is both stored in gbm@assays$RNA@counts and gbm@assays$RNA@data . Formal class 'Seurat' [package \"SeuratObject\"] with 13 slots ..@ assays :List of 1 .. ..$ RNA:Formal class 'Assay' [package \"SeuratObject\"] with 8 slots .. .. .. ..@ counts :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots .. .. .. .. .. ..@ i : int [1:19378876] 18 67 82 116 118 158 173 227 240 281 ... .. .. .. .. .. ..@ p : int [1:5554] 0 815 5575 7894 11289 14005 15664 16654 16792 19905 ... .. .. .. .. .. ..@ Dim : int [1:2] 24363 5553 .. .. .. .. .. ..@ Dimnames:List of 2 .. .. .. .. .. .. ..$ : chr [1:24363] \"AL627309.1\" \"AL627309.5\" \"AP006222.2\" \"LINC01409\" ... .. .. .. .. .. .. ..$ : chr [1:5553] \"AAACCCAAGGCGATAC-1\" \"AAACCCACAAGTCCCG-1\" \"AAACCCACAGATGCGA-1\" \"AAACCCACAGGTGAGT-1\" ... .. .. .. .. .. ..@ x : num [1:19378876] 1 1 1 1 5 1 1 1 1 1 ... .. .. .. .. .. ..@ factors : list() .. .. .. ..@ data :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots .. .. .. .. .. ..@ i : int [1:19378876] 18 67 82 116 118 158 173 227 240 281 ... .. .. .. .. .. ..@ p : int [1:5554] 0 815 5575 7894 11289 14005 15664 16654 16792 19905 ... .. .. .. .. .. ..@ Dim : int [1:2] 24363 5553 .. .. .. .. .. ..@ Dimnames:List of 2 .. .. .. .. .. .. ..$ : chr [1:24363] \"AL627309.1\" \"AL627309.5\" \"AP006222.2\" \"LINC01409\" ... .. .. .. .. .. .. ..$ : chr [1:5553] \"AAACCCAAGGCGATAC-1\" \"AAACCCACAAGTCCCG-1\" \"AAACCCACAGATGCGA-1\" \"AAACCCACAGGTGAGT-1\" ... .. .. .. .. .. ..@ x : num [1:19378876] 1 1 1 1 5 1 1 1 1 1 ... .. .. .. .. .. ..@ factors : list() .. .. .. ..@ scale.data : num[0 , 0 ] .. .. .. ..@ key : chr \"rna_\" .. .. .. ..@ assay.orig : NULL .. .. .. ..@ var.features : logi(0) .. .. .. ..@ meta.features:'data.frame': 24363 obs. of 0 variables .. .. .. ..@ misc : list() ..@ meta.data :'data.frame': 5553 obs. of 3 variables: .. ..$ orig.ident : Factor w/ 1 level \"gbm\": 1 1 1 1 1 1 1 1 1 1 ... .. ..$ nCount_RNA : num [1:5553] 2225 17882 8172 9057 5612 ... .. ..$ nFeature_RNA: int [1:5553] 815 4760 2319 3395 2716 1659 990 138 3113 6045 ... ..@ active.assay: chr \"RNA\" ..@ active.ident: Factor w/ 1 level \"gbm\": 1 1 1 1 1 1 1 1 1 1 ... .. ..- attr(*, \"names\")= chr [1:5553] \"AAACCCAAGGCGATAC-1\" \"AAACCCACAAGTCCCG-1\" \"AAACCCACAGATGCGA-1\" \"AAACCCACAGGTGAGT-1\" ... ..@ graphs : list() ..@ neighbors : list() ..@ reductions : list() ..@ images : list() ..@ project.name: chr \"gbm\" ..@ misc : list() ..@ version :Classes 'package_version', 'numeric_version' hidden list of 1 .. ..$ : int [1:3] 4 0 1 ..@ commands : list() ..@ tools : list() Answer B Running head(gbm@meta.data) returns: orig.ident nCount_RNA nFeature_RNA AAACCCAAGGCGATAC-1 gbm 2225 815 AAACCCACAAGTCCCG-1 gbm 17882 4760 AAACCCACAGATGCGA-1 gbm 8172 2319 AAACCCACAGGTGAGT-1 gbm 9057 3395 AAACCCAGTCTTGCGG-1 gbm 5612 2716 AAACCCATCGATAACC-1 gbm 6254 1659 Giving you the names of three columns and a row for each cell: orig_ident : the original identity (origin) of a cell. nCount_RNA : the number of reads assigned to a cell. nFeature_RNA : the number of expressed features (genes) per cell. Luckily, usually you do not have to dive into this structure to retrieve information. For example, information in the slot @meta.data can be retrieved and set by using $ or [[]] . Note There is a subtle difference here between $ and [[]] . While $ returns a vector of the column in @meta.data , [[]] returns a data.frame . Exercise: Generate a histogram of the column nCount_RNA at gbm@meta.data , with the base function hist . Answer hist ( gbm $ nCount_RNA ) or hist ( gbm @ meta.data $ nCount_RNA ) There are also built-in functions to plot data from Seurat object, for example FeatureScatter . This function enables you easily draw a scatterplot from a Seurat object: Seurat :: FeatureScatter ( gbm , feature1 = \"nCount_RNA\" , feature2 = \"nFeature_RNA\" ) Basic Quality Control A high number of UMIs originating from mitochondrial genes can point to dying cells. In order to calculate the percentage of UMIs coming from mitochondrial genes for each cell, we use the function PercentageFeatureSet . In our count matrix, the names of mitochondrial genes all start with MT- , so we can use that pattern to search these genes: gbm[[ \"percent.mt\" ]] <- Seurat :: PercentageFeatureSet ( gbm , pattern = \"^MT-\" ) Finding mitochondrial genes for mouse For mouse, mitochondrial genes start with mt- , so the function call with look like this: gbm[[ \"percent.mt\" ]] <- Seurat :: PercentageFeatureSet ( gbm , pattern = \"^mt-\" ) Now check out whether the column was added to the meta.data slot: head ( gbm @ meta.data ) Let\u2019s have a look at the distribution of the three columns stored in @meta.data : Seurat :: VlnPlot ( gbm , features = c ( \"nFeature_RNA\" , \"nCount_RNA\" , \"percent.mt\" ), ncol = 3 ) There is often a relationship between number of UMIs and percentage of mitochondrial genes. We can have a look at their relationship: Seurat :: FeatureScatter ( gbm , feature1 = \"nCount_RNA\" , feature2 = \"percent.mt\" ) Based on what we know now, it would be sensible to keep cells that express between 500 and 7500 features, and in which less than 20% of the UMIs come from mitochondrial genes. We can filter like this: gbm <- subset ( gbm , subset = nFeature_RNA > 500 & nFeature_RNA < 7500 & percent.mt < 20 ) Exercise: How many cells did we filter out? Answer Just running gbm returns: An object of class Seurat 24363 features across 5091 samples within 1 assay Active assay: RNA (24363 features, 0 variable features) Meaning that 5553 - 5091 = 462 cells were filtered out.","title":"Introduction scRNAseq"},{"location":"day1/introduction_scrnaseq/#learning-outcomes","text":"After having completed this chapter you will be able to: Explain what kind of information single cell RNA-seq can give you to answer a biological question Describe essential considerations during the design of a single cell RNA-seq experiment Describe the pros and cons of different single cell sequencing methods Load single cell data into R Explain the basic structure of a Seurat object and extract count data and metadata Perform a basic quality control by: Evaluating the percentage of UMIs originating from mitochondrial genes Detecting doublets","title":"Learning outcomes"},{"location":"day1/introduction_scrnaseq/#material","text":"Download the presentation Seurat website Paper on experimental considerations Paper on experimental design SMART-seq3 protocol at protocols.io","title":"Material"},{"location":"day1/introduction_scrnaseq/#exercises","text":"","title":"Exercises"},{"location":"day1/introduction_scrnaseq/#login-and-set-up","text":"Log in to Rstudio server with the provided link and password, your username is rstudio . First, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project\u2026 Continue by choosing New Directory As project type select New Project Finally, type in the project name. This should be single_cell_course . Finish by clicking Create Project . Now that we have setup a project and a project directory (it is in /home/rstudio/single_cell_course ), we can download the data that is required for this course. We will use the built-in terminal of Rstudio. To do this, select the Terminal tab:","title":"Login and set up"},{"location":"day1/introduction_scrnaseq/#downloading-the-course-data","text":"To download and extract the dataset, copy-paste these commands inside the terminal tab: wget https://single-cell-transcriptomics.s3.eu-central-1.amazonaws.com/scRNAseq_v2.tar.gz tar -xvf scRNAseq_v2.tar.gz rm scRNAseq_v2.tar.gz Have a look at the data directory you have downloaded. It should contain the following: ./data \u251c\u2500\u2500 deng_dataset \u2502 \u2514\u2500\u2500 deng-reads.rds \u251c\u2500\u2500 gbm_dataset \u2502 \u251c\u2500\u2500 de_genes_gbm_res.0.2.csv \u2502 \u251c\u2500\u2500 dissocation_genes.txt \u2502 \u251c\u2500\u2500 filtered_feature_bc_matrix \u2502 \u2502 \u251c\u2500\u2500 barcodes.tsv.gz \u2502 \u2502 \u251c\u2500\u2500 features.tsv.gz \u2502 \u2502 \u2514\u2500\u2500 matrix.mtx.gz \u2502 \u2514\u2500\u2500 h.all.v7.2.symbols.xls \u2514\u2500\u2500 pancreas_dataset \u251c\u2500\u2500 pancreas_expression_matrix.rds \u2514\u2500\u2500 pancreas_metadata.rds Bug Add more information on origin of the data here We will be working with three different datasets: gbm_dataset : This will be our most used dataset, we will use it throughout the course pancreas_dataset : Pancreas cell dataset generated with four different methods. We will use it for integration and differential gene expression analysis deng_dataset : Cell development dataset, which we will use for trajectory analysis at day 3","title":"Downloading the course data"},{"location":"day1/introduction_scrnaseq/#loading-scrnaseq-data","text":"This part uses the gbm dataset Today we will mainly work with the package Seurat . Load it into your environment like this: library ( Seurat ) To run through a typical Seurat analysis, we will use the files that are in the directory data/filtered_feature_bc_matrix . This directory is part of the output generated by cellranger . To load in this data into R and generate a sparse matrix, run the following command: gbm.data <- Seurat :: Read10X ( data.dir = \"data/gbm_dataset/filtered_feature_bc_matrix/\" ) Basically, this imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running: gbm.data [c ( \"PECAM1\" , \"CD8A\" , \"TSPAN1\" ), 1 : 30 ] To generate a Seurat object, we will run CreateSeuratObject . We choose to import only features (genes) that are expressed in at least 3 cells, and we include only cells that express 100 or more genes (features): gbm <- Seurat :: CreateSeuratObject ( counts = gbm.data , project = \"gbm\" , min.cells = 3 , min.features = 100 ) Function notation with :: Here, we define the function together with its associated package. We do that by the syntax package::function . Of course, you can also call library(package) , and only type the function name. Since we use many different packages in this course, it can be confusing which function comes from which package. Therefore, we chose to always associate the package with the called function. Exercise: check what\u2019s in the gbm object, by typing gbm in the R console. How many features are in there? And how many cells? Answer Typing gbm should return: An object of class Seurat 24363 features across 5553 samples within 1 assay Active assay: RNA (24363 features, 0 variable features) This means that we have 24363 genes (features) in there, and 5553 cells (samples)","title":"Loading scRNAseq data"},{"location":"day1/introduction_scrnaseq/#the-seurat-object","text":"The gbm object we have created has the class Seurat . The object structure is rather complex, since it contains multi-level lists and slots. Exercise: A. Have a look at the gbm object by running str(gbm) . What is in there? Where in the object is the count data stored? B. Have a look at the data.frame stored at gbm@meta.data what kind of information is in there? Answer Answer A Running str(gbm) shows you that the object contains many slots with different classes. The count data is both stored in gbm@assays$RNA@counts and gbm@assays$RNA@data . Formal class 'Seurat' [package \"SeuratObject\"] with 13 slots ..@ assays :List of 1 .. ..$ RNA:Formal class 'Assay' [package \"SeuratObject\"] with 8 slots .. .. .. ..@ counts :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots .. .. .. .. .. ..@ i : int [1:19378876] 18 67 82 116 118 158 173 227 240 281 ... .. .. .. .. .. ..@ p : int [1:5554] 0 815 5575 7894 11289 14005 15664 16654 16792 19905 ... .. .. .. .. .. ..@ Dim : int [1:2] 24363 5553 .. .. .. .. .. ..@ Dimnames:List of 2 .. .. .. .. .. .. ..$ : chr [1:24363] \"AL627309.1\" \"AL627309.5\" \"AP006222.2\" \"LINC01409\" ... .. .. .. .. .. .. ..$ : chr [1:5553] \"AAACCCAAGGCGATAC-1\" \"AAACCCACAAGTCCCG-1\" \"AAACCCACAGATGCGA-1\" \"AAACCCACAGGTGAGT-1\" ... .. .. .. .. .. ..@ x : num [1:19378876] 1 1 1 1 5 1 1 1 1 1 ... .. .. .. .. .. ..@ factors : list() .. .. .. ..@ data :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots .. .. .. .. .. ..@ i : int [1:19378876] 18 67 82 116 118 158 173 227 240 281 ... .. .. .. .. .. ..@ p : int [1:5554] 0 815 5575 7894 11289 14005 15664 16654 16792 19905 ... .. .. .. .. .. ..@ Dim : int [1:2] 24363 5553 .. .. .. .. .. ..@ Dimnames:List of 2 .. .. .. .. .. .. ..$ : chr [1:24363] \"AL627309.1\" \"AL627309.5\" \"AP006222.2\" \"LINC01409\" ... .. .. .. .. .. .. ..$ : chr [1:5553] \"AAACCCAAGGCGATAC-1\" \"AAACCCACAAGTCCCG-1\" \"AAACCCACAGATGCGA-1\" \"AAACCCACAGGTGAGT-1\" ... .. .. .. .. .. ..@ x : num [1:19378876] 1 1 1 1 5 1 1 1 1 1 ... .. .. .. .. .. ..@ factors : list() .. .. .. ..@ scale.data : num[0 , 0 ] .. .. .. ..@ key : chr \"rna_\" .. .. .. ..@ assay.orig : NULL .. .. .. ..@ var.features : logi(0) .. .. .. ..@ meta.features:'data.frame': 24363 obs. of 0 variables .. .. .. ..@ misc : list() ..@ meta.data :'data.frame': 5553 obs. of 3 variables: .. ..$ orig.ident : Factor w/ 1 level \"gbm\": 1 1 1 1 1 1 1 1 1 1 ... .. ..$ nCount_RNA : num [1:5553] 2225 17882 8172 9057 5612 ... .. ..$ nFeature_RNA: int [1:5553] 815 4760 2319 3395 2716 1659 990 138 3113 6045 ... ..@ active.assay: chr \"RNA\" ..@ active.ident: Factor w/ 1 level \"gbm\": 1 1 1 1 1 1 1 1 1 1 ... .. ..- attr(*, \"names\")= chr [1:5553] \"AAACCCAAGGCGATAC-1\" \"AAACCCACAAGTCCCG-1\" \"AAACCCACAGATGCGA-1\" \"AAACCCACAGGTGAGT-1\" ... ..@ graphs : list() ..@ neighbors : list() ..@ reductions : list() ..@ images : list() ..@ project.name: chr \"gbm\" ..@ misc : list() ..@ version :Classes 'package_version', 'numeric_version' hidden list of 1 .. ..$ : int [1:3] 4 0 1 ..@ commands : list() ..@ tools : list() Answer B Running head(gbm@meta.data) returns: orig.ident nCount_RNA nFeature_RNA AAACCCAAGGCGATAC-1 gbm 2225 815 AAACCCACAAGTCCCG-1 gbm 17882 4760 AAACCCACAGATGCGA-1 gbm 8172 2319 AAACCCACAGGTGAGT-1 gbm 9057 3395 AAACCCAGTCTTGCGG-1 gbm 5612 2716 AAACCCATCGATAACC-1 gbm 6254 1659 Giving you the names of three columns and a row for each cell: orig_ident : the original identity (origin) of a cell. nCount_RNA : the number of reads assigned to a cell. nFeature_RNA : the number of expressed features (genes) per cell. Luckily, usually you do not have to dive into this structure to retrieve information. For example, information in the slot @meta.data can be retrieved and set by using $ or [[]] . Note There is a subtle difference here between $ and [[]] . While $ returns a vector of the column in @meta.data , [[]] returns a data.frame . Exercise: Generate a histogram of the column nCount_RNA at gbm@meta.data , with the base function hist . Answer hist ( gbm $ nCount_RNA ) or hist ( gbm @ meta.data $ nCount_RNA ) There are also built-in functions to plot data from Seurat object, for example FeatureScatter . This function enables you easily draw a scatterplot from a Seurat object: Seurat :: FeatureScatter ( gbm , feature1 = \"nCount_RNA\" , feature2 = \"nFeature_RNA\" )","title":"The Seurat object"},{"location":"day1/introduction_scrnaseq/#basic-quality-control","text":"A high number of UMIs originating from mitochondrial genes can point to dying cells. In order to calculate the percentage of UMIs coming from mitochondrial genes for each cell, we use the function PercentageFeatureSet . In our count matrix, the names of mitochondrial genes all start with MT- , so we can use that pattern to search these genes: gbm[[ \"percent.mt\" ]] <- Seurat :: PercentageFeatureSet ( gbm , pattern = \"^MT-\" ) Finding mitochondrial genes for mouse For mouse, mitochondrial genes start with mt- , so the function call with look like this: gbm[[ \"percent.mt\" ]] <- Seurat :: PercentageFeatureSet ( gbm , pattern = \"^mt-\" ) Now check out whether the column was added to the meta.data slot: head ( gbm @ meta.data ) Let\u2019s have a look at the distribution of the three columns stored in @meta.data : Seurat :: VlnPlot ( gbm , features = c ( \"nFeature_RNA\" , \"nCount_RNA\" , \"percent.mt\" ), ncol = 3 ) There is often a relationship between number of UMIs and percentage of mitochondrial genes. We can have a look at their relationship: Seurat :: FeatureScatter ( gbm , feature1 = \"nCount_RNA\" , feature2 = \"percent.mt\" ) Based on what we know now, it would be sensible to keep cells that express between 500 and 7500 features, and in which less than 20% of the UMIs come from mitochondrial genes. We can filter like this: gbm <- subset ( gbm , subset = nFeature_RNA > 500 & nFeature_RNA < 7500 & percent.mt < 20 ) Exercise: How many cells did we filter out? Answer Just running gbm returns: An object of class Seurat 24363 features across 5091 samples within 1 assay Active assay: RNA (24363 features, 0 variable features) Meaning that 5553 - 5091 = 462 cells were filtered out.","title":"Basic Quality Control"},{"location":"day1/normalization_scaling/","text":"Learning outcomes After having completed this chapter you will be able to: Describe and perform standard procedures for normalization and scaling with the package Seurat Select the most variable genes from a Seurat object for downstream analyses Material Seurat vignette Exercises This chapter uses the gbm dataset Normalization Bug Recommendations are unclear here. Should we use the NormalizeData -> FindVariableFeatures -> ScaleData workflow or SCTransform ?? After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method \"LogNormalize\" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in the \u201cRNA\u201d slot of the gbm object. Exercise: Have a look at the assay data before and after running NormalizeData() . Did it change? Hint You can extract assay data with the function Seurat::GetAssay Answer You can check out some assay data with: Seurat :: GetAssay ( gbm ) [1 : 10 , 1 : 10 ] Returning: Before normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018AAACCCAAGGCGATAC-1\u2019, \u2018AAACCCACAAGTCCCG-1\u2019, \u2018AAACCCACAGATGCGA-1\u2019 ... ]] AL627309.1 . . . . . . . . . . AL627309.5 . . . . . . . . . . AP006222.2 . . . . . . . . . . LINC01409 . . . 1 . . . . . . FAM87B . . . . . . . . . . LINC01128 . . 1 . . . . 1 . 1 LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . AL645608.6 . . . . . . . . . . AL645608.2 . . . . . . . . . . After normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018AAACCCAAGGCGATAC-1\u2019, \u2018AAACCCACAAGTCCCG-1\u2019, \u2018AAACCCACAGATGCGA-1\u2019 ... ]] AL627309.1 . . . . . . . . . . AL627309.5 . . . . . . . . . . AP006222.2 . . . . . . . . . . LINC01409 . . . 0.7438965 . . . . . . FAM87B . . . . . . . . . . LINC01128 . . 0.7991683 . . . . 0.5091777 . 0.3826447 LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . AL645608.6 . . . . . . . . . . AL645608.2 . . . . . . . . . . gbm <- Seurat :: NormalizeData ( gbm , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) Updating gbm As you might have noticed, this function takes the object gbm as input, and it returns it to an object named gbm . We can do this because the output of such calculations are added to the object, without loosing information. Variable features We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, 2,000 genes (features) per dataset are returned and these will be used in downstream analysis, like PCA. gbm <- Seurat :: FindVariableFeatures ( gbm , selection.method = \"vst\" , nfeatures = 2000 ) Let\u2019s have a look at the 10 most variable genes: # Identify the 10 most highly variable genes top10 <- head ( Seurat :: VariableFeatures ( gbm ), 10 ) top10 We can plot them in a nicely labeled scatterplot: vf_plot <- Seurat :: VariableFeaturePlot ( gbm ) Seurat :: LabelPoints ( plot = vf_plot , points = top10 , repel = TRUE ) Scaling Next, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function shifts the expression of each gene, so that the mean expression across cells is 0 scales the expression of each gene, so that the variance across cells is 1 This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate. The results of this are stored in gbm$RNA@scale.data gbm <- Seurat :: ScaleData ( gbm , features = rownames ( gbm )) Here\u2019s a function to plot mean versus variance in a count matrix (credits go to Wandrille Duchemin): plot_mean_variance <- function ( count_mat ){ # get log10 of mean per gene log_mean <- log10 ( rowMeans ( count_mat )) # get log10 of variance per gene log_var <- log10 ( apply ( count_mat , 1 , var )) # get density colors cols <- densCols ( log_mean , log_var ) plot ( log_mean , log_var , col = cols , pch = 19 , cex = 0.2 , xlab = \"log10(mean)\" , ylab = \"log10(variation)\" ) # draw the line y=x abline ( 0 , 1 , col = \"red\" ) } Exercise: Use the above function to plot the mean variance of: raw counts (stored in the slot \"counts\" ) normalized data (stored in the slot \"data\" ) scaled data (stored in the slot \"scale.data\" ) Retrieving count data You can retrieve count data from a specific slot with the function GetAssayData , e.g. for the raw counts this would be: Seurat :: GetAssayData ( gbm , slot = \"counts\" ) Answer Raw counts Running plot_mean_variance ( Seurat :: GetAssayData ( gbm , slot = \"counts\" )) Returns: Normalized data Running plot_mean_variance ( Seurat :: GetAssayData ( gbm , slot = \"data\" )) Returns: Scaled and normalized Running plot_mean_variance ( Seurat :: GetAssayData ( gbm , slot = \"scale.data\" )) As you remember, scaling results in a variance of 1 for each gene, so the log10 of the variance would be 0. In addition, the mean is scaled to zero, so a log10 of 0 would return -Inf or a very negative number (in case it\u2019s very close to 0). It therefore returns:","title":"Normalization and scaling"},{"location":"day1/normalization_scaling/#learning-outcomes","text":"After having completed this chapter you will be able to: Describe and perform standard procedures for normalization and scaling with the package Seurat Select the most variable genes from a Seurat object for downstream analyses","title":"Learning outcomes"},{"location":"day1/normalization_scaling/#material","text":"Seurat vignette","title":"Material"},{"location":"day1/normalization_scaling/#exercises","text":"This chapter uses the gbm dataset","title":"Exercises"},{"location":"day1/normalization_scaling/#normalization","text":"Bug Recommendations are unclear here. Should we use the NormalizeData -> FindVariableFeatures -> ScaleData workflow or SCTransform ?? After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method \"LogNormalize\" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in the \u201cRNA\u201d slot of the gbm object. Exercise: Have a look at the assay data before and after running NormalizeData() . Did it change? Hint You can extract assay data with the function Seurat::GetAssay Answer You can check out some assay data with: Seurat :: GetAssay ( gbm ) [1 : 10 , 1 : 10 ] Returning: Before normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018AAACCCAAGGCGATAC-1\u2019, \u2018AAACCCACAAGTCCCG-1\u2019, \u2018AAACCCACAGATGCGA-1\u2019 ... ]] AL627309.1 . . . . . . . . . . AL627309.5 . . . . . . . . . . AP006222.2 . . . . . . . . . . LINC01409 . . . 1 . . . . . . FAM87B . . . . . . . . . . LINC01128 . . 1 . . . . 1 . 1 LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . AL645608.6 . . . . . . . . . . AL645608.2 . . . . . . . . . . After normalization 10 x 10 sparse Matrix of class \"dgCMatrix\" [[ suppressing 10 column names \u2018AAACCCAAGGCGATAC-1\u2019, \u2018AAACCCACAAGTCCCG-1\u2019, \u2018AAACCCACAGATGCGA-1\u2019 ... ]] AL627309.1 . . . . . . . . . . AL627309.5 . . . . . . . . . . AP006222.2 . . . . . . . . . . LINC01409 . . . 0.7438965 . . . . . . FAM87B . . . . . . . . . . LINC01128 . . 0.7991683 . . . . 0.5091777 . 0.3826447 LINC00115 . . . . . . . . . . FAM41C . . . . . . . . . . AL645608.6 . . . . . . . . . . AL645608.2 . . . . . . . . . . gbm <- Seurat :: NormalizeData ( gbm , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) Updating gbm As you might have noticed, this function takes the object gbm as input, and it returns it to an object named gbm . We can do this because the output of such calculations are added to the object, without loosing information.","title":"Normalization"},{"location":"day1/normalization_scaling/#variable-features","text":"We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, 2,000 genes (features) per dataset are returned and these will be used in downstream analysis, like PCA. gbm <- Seurat :: FindVariableFeatures ( gbm , selection.method = \"vst\" , nfeatures = 2000 ) Let\u2019s have a look at the 10 most variable genes: # Identify the 10 most highly variable genes top10 <- head ( Seurat :: VariableFeatures ( gbm ), 10 ) top10 We can plot them in a nicely labeled scatterplot: vf_plot <- Seurat :: VariableFeaturePlot ( gbm ) Seurat :: LabelPoints ( plot = vf_plot , points = top10 , repel = TRUE )","title":"Variable features"},{"location":"day1/normalization_scaling/#scaling","text":"Next, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function shifts the expression of each gene, so that the mean expression across cells is 0 scales the expression of each gene, so that the variance across cells is 1 This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate. The results of this are stored in gbm$RNA@scale.data gbm <- Seurat :: ScaleData ( gbm , features = rownames ( gbm )) Here\u2019s a function to plot mean versus variance in a count matrix (credits go to Wandrille Duchemin): plot_mean_variance <- function ( count_mat ){ # get log10 of mean per gene log_mean <- log10 ( rowMeans ( count_mat )) # get log10 of variance per gene log_var <- log10 ( apply ( count_mat , 1 , var )) # get density colors cols <- densCols ( log_mean , log_var ) plot ( log_mean , log_var , col = cols , pch = 19 , cex = 0.2 , xlab = \"log10(mean)\" , ylab = \"log10(variation)\" ) # draw the line y=x abline ( 0 , 1 , col = \"red\" ) } Exercise: Use the above function to plot the mean variance of: raw counts (stored in the slot \"counts\" ) normalized data (stored in the slot \"data\" ) scaled data (stored in the slot \"scale.data\" ) Retrieving count data You can retrieve count data from a specific slot with the function GetAssayData , e.g. for the raw counts this would be: Seurat :: GetAssayData ( gbm , slot = \"counts\" ) Answer Raw counts Running plot_mean_variance ( Seurat :: GetAssayData ( gbm , slot = \"counts\" )) Returns: Normalized data Running plot_mean_variance ( Seurat :: GetAssayData ( gbm , slot = \"data\" )) Returns: Scaled and normalized Running plot_mean_variance ( Seurat :: GetAssayData ( gbm , slot = \"scale.data\" )) As you remember, scaling results in a variance of 1 for each gene, so the log10 of the variance would be 0. In addition, the mean is scaled to zero, so a log10 of 0 would return -Inf or a very negative number (in case it\u2019s very close to 0). It therefore returns:","title":"Scaling"},{"location":"day1/quality_control/","text":"Learning outcomes After having completed this chapter you will be able to: Assign cell cycle phases to a single cell dataset Use the package scater evaluate cell quality based on reads originating from: mitochondrial genes ribosomal genes dissociation-related genes Evaluate confounding effects on expression data by analyzing the explained variance Material Download the presentation Exercises This chapter uses the gbm dataset Cell cycle analysis Cells can be captured in different cycling phases, which can be identified. A list of cell cycle markers is described by: Tirosh I, Izar B, Prakadan SM, Wadsworth MH, Treacy D, Trombetta JJ, et al. Dissecting the multicellular ecosystem of metastatic melanoma by single-cell RNA-seq. Science. 2016;352:189\u201396. The dataset is directly available from Seurat: Seurat :: cc.genes.updated.2019 Extract the genes specific to the S phase and to the G2/M phase: s.genes <- Seurat :: cc.genes.updated.2019 $ s.genes g2m.genes <- Seurat :: cc.genes.updated.2019 $ g2m.genes The CellCycleScoring() function allows to assign cell cycle phase information to each cell, stored in the metadata as the \u201cS.Score\u201d, \u201cG2M.Score\u201d and \u201cPhase\u201d columns gbm <- Seurat :: CellCycleScoring ( gbm , s.features = s.genes , g2m.features = g2m.genes ) head ( gbm ) table ( gbm $ Phase ) # G1 G2M S # 2887 711 1493 Visualize the distribution of cell cycle markers: Seurat :: RidgePlot ( gbm , features = c ( \"PCNA\" , \"MKI67\" ), group.by = \"orig.ident\" , ncol = 2 ) We can proceed with downstream analysis without removing cell cycle for example, perform clustering, and come back to remove the effect of cell cycle if we identify a cluster of cells which is mostly composed of G2/M cells for example. Alternative QC exploration using the scater package Scater includes different types of quality controls: QC and filtering of cells QC and filtering of features (genes) QC of experimental variables the scater package as well as other bioconductor packages, rely on an object of the class SingleCellExperiment : cts <- Seurat :: GetAssayData ( gbm , slot = \"counts\" ) gbm_sce <- SingleCellExperiment :: SingleCellExperiment ( assays = list ( counts = cts ), colData = gbm @ meta.data , rowData = rownames ( gbm ) ) class ( gbm ) class ( gbm_sce ) gbm_sce We can again check percent mitochondrial gene expression as well as dissociation protocol-related gene expression. Genes associated with the dissociation protocol, i.e. stress genes, can sometimes cause clustering of stressed cells apart from the other cells. They have been described by: Van Den Brink SC, Sage F, V\u00e9rtesy \u00c1, Spanjaard B, Peterson-Maduro J, Baron CS, et al. Single-cell sequencing reveals dissociation-induced gene expression in tissue subpopulations. Nat Methods. 2017;14:935\u20136. And are availabe in the file data/dissocation_genes.txt . Load these into a vector, and generate also a vector of ribosomal genes and mitochondrial genes: dissoc_genes <- readLines ( \"data/gbm_dataset/dissocation_genes.txt\" ) ribo_genes <- rownames ( gbm ) [grep ( pattern = \"^RP[S|L]\" , rownames ( gbm ), perl = T ) ] mito_genes <- rownames ( gbm ) [grep ( pattern = \"^MT-\" , rownames ( gbm )) ] scater calls the addPerCellQC function of the scuttle package to compute a number of quality control metrics for each cell and feature (i.e gene) gbm_sce <- scuttle :: addPerCellQC ( gbm_sce , subsets = list ( mito_genes = which ( rownames ( gbm_sce ) %in% mito_genes ), dissoc_genes = which ( rownames ( gbm_sce ) %in% dissoc_genes ), ribo_genes = which ( rownames ( gbm_sce ) %in% ribo_genes ))) SingleCellExperiment :: colData ( gbm_sce ) scater :: plotColData ( gbm_sce , x = \"sum\" , y = \"detected\" ) scater :: plotColData ( gbm_sce , x = \"detected\" , y = \"subsets_mito_genes_percent\" ) scater :: plotColData ( gbm_sce , x = \"detected\" , y = \"subsets_dissoc_genes_percent\" ) scater :: plotColData ( gbm_sce , x = \"subsets_mito_genes_percent\" , y = \"subsets_ribo_genes_percent\" ) On the gene level, we can look at a plot that shows the top (by default 50) most-expressed genes. Each row in the plot corresponds to a gene; each bar corresponds to the expression of a gene in a single cell; and the circle indicates the median expression of each gene, with which genes are sorted. We expect to see the \u201cusual suspects\u201d, i.e., mitochondrial genes, actin, ribosomal protein, MALAT1. If used, few spike-in transcripts may also be present here, though if all of the spike-ins are in the top 50, it suggests that too much spike-in RNA was added. A large number of pseudo-genes or predicted genes may indicate problems with alignment. scater :: plotHighestExprs ( gbm_sce , exprs_values = \"counts\" , n = 30 ) Variable-level metrics are computed by the getVarianceExplained() function (after normalization, see below). This calculates the percentage of variance of each gene\u2019s expression that is explained by each variable in the colData of the SingleCellExperiment object. We can then use this to determine which experimental factors are contributing most to the variance in expression. This is useful for diagnosing batch effects or to quickly verify that a treatment has an effect. First, computing variance explained on the log-counts, so that the statistics reflect changes in relative expression. gbm_sce <- scater :: logNormCounts ( gbm_sce ) # alternative to Seurat's normalization here using scater In the gbm dataset, we only have 1 patient, so we cannot calculate the effect of experimental variables like sex or donor id, but in case we would have several variables, here is the method with the cell cycle phase as example: vars <- scater :: getVarianceExplained ( gbm_sce , variables = \"Phase\" ) head ( vars ) A distribution of percentage variance explained by each gene is shown, and can indicate whether one or the other experimental variable has high contribution to the variance in the data: scater :: plotExplanatoryVariables ( vars ) If we think that the cell cycling has an effect on the analysis, and if we want to \u201cremove\u201d this effect so that cycling cells are integrated into the rest of the cells and not clustering apart anymore, we can regress out the cell cycling phase at the moment of normalizing the data using ScaleData . This might be slow to compute # do not run gbm_cc <- Seurat :: ScaleData ( gbm , vars.to.regress = c ( \"S.Score\" , \"G2M.Score\" )) Save the dataset and clear environment Now, save the dataset so you can use it tomorrow: saveRDS ( gbm , \"gbm_day1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Quality control"},{"location":"day1/quality_control/#learning-outcomes","text":"After having completed this chapter you will be able to: Assign cell cycle phases to a single cell dataset Use the package scater evaluate cell quality based on reads originating from: mitochondrial genes ribosomal genes dissociation-related genes Evaluate confounding effects on expression data by analyzing the explained variance","title":"Learning outcomes"},{"location":"day1/quality_control/#material","text":"Download the presentation","title":"Material"},{"location":"day1/quality_control/#exercises","text":"This chapter uses the gbm dataset","title":"Exercises"},{"location":"day1/quality_control/#cell-cycle-analysis","text":"Cells can be captured in different cycling phases, which can be identified. A list of cell cycle markers is described by: Tirosh I, Izar B, Prakadan SM, Wadsworth MH, Treacy D, Trombetta JJ, et al. Dissecting the multicellular ecosystem of metastatic melanoma by single-cell RNA-seq. Science. 2016;352:189\u201396. The dataset is directly available from Seurat: Seurat :: cc.genes.updated.2019 Extract the genes specific to the S phase and to the G2/M phase: s.genes <- Seurat :: cc.genes.updated.2019 $ s.genes g2m.genes <- Seurat :: cc.genes.updated.2019 $ g2m.genes The CellCycleScoring() function allows to assign cell cycle phase information to each cell, stored in the metadata as the \u201cS.Score\u201d, \u201cG2M.Score\u201d and \u201cPhase\u201d columns gbm <- Seurat :: CellCycleScoring ( gbm , s.features = s.genes , g2m.features = g2m.genes ) head ( gbm ) table ( gbm $ Phase ) # G1 G2M S # 2887 711 1493 Visualize the distribution of cell cycle markers: Seurat :: RidgePlot ( gbm , features = c ( \"PCNA\" , \"MKI67\" ), group.by = \"orig.ident\" , ncol = 2 ) We can proceed with downstream analysis without removing cell cycle for example, perform clustering, and come back to remove the effect of cell cycle if we identify a cluster of cells which is mostly composed of G2/M cells for example.","title":"Cell cycle analysis"},{"location":"day1/quality_control/#alternative-qc-exploration-using-the-scater-package","text":"Scater includes different types of quality controls: QC and filtering of cells QC and filtering of features (genes) QC of experimental variables the scater package as well as other bioconductor packages, rely on an object of the class SingleCellExperiment : cts <- Seurat :: GetAssayData ( gbm , slot = \"counts\" ) gbm_sce <- SingleCellExperiment :: SingleCellExperiment ( assays = list ( counts = cts ), colData = gbm @ meta.data , rowData = rownames ( gbm ) ) class ( gbm ) class ( gbm_sce ) gbm_sce We can again check percent mitochondrial gene expression as well as dissociation protocol-related gene expression. Genes associated with the dissociation protocol, i.e. stress genes, can sometimes cause clustering of stressed cells apart from the other cells. They have been described by: Van Den Brink SC, Sage F, V\u00e9rtesy \u00c1, Spanjaard B, Peterson-Maduro J, Baron CS, et al. Single-cell sequencing reveals dissociation-induced gene expression in tissue subpopulations. Nat Methods. 2017;14:935\u20136. And are availabe in the file data/dissocation_genes.txt . Load these into a vector, and generate also a vector of ribosomal genes and mitochondrial genes: dissoc_genes <- readLines ( \"data/gbm_dataset/dissocation_genes.txt\" ) ribo_genes <- rownames ( gbm ) [grep ( pattern = \"^RP[S|L]\" , rownames ( gbm ), perl = T ) ] mito_genes <- rownames ( gbm ) [grep ( pattern = \"^MT-\" , rownames ( gbm )) ] scater calls the addPerCellQC function of the scuttle package to compute a number of quality control metrics for each cell and feature (i.e gene) gbm_sce <- scuttle :: addPerCellQC ( gbm_sce , subsets = list ( mito_genes = which ( rownames ( gbm_sce ) %in% mito_genes ), dissoc_genes = which ( rownames ( gbm_sce ) %in% dissoc_genes ), ribo_genes = which ( rownames ( gbm_sce ) %in% ribo_genes ))) SingleCellExperiment :: colData ( gbm_sce ) scater :: plotColData ( gbm_sce , x = \"sum\" , y = \"detected\" ) scater :: plotColData ( gbm_sce , x = \"detected\" , y = \"subsets_mito_genes_percent\" ) scater :: plotColData ( gbm_sce , x = \"detected\" , y = \"subsets_dissoc_genes_percent\" ) scater :: plotColData ( gbm_sce , x = \"subsets_mito_genes_percent\" , y = \"subsets_ribo_genes_percent\" ) On the gene level, we can look at a plot that shows the top (by default 50) most-expressed genes. Each row in the plot corresponds to a gene; each bar corresponds to the expression of a gene in a single cell; and the circle indicates the median expression of each gene, with which genes are sorted. We expect to see the \u201cusual suspects\u201d, i.e., mitochondrial genes, actin, ribosomal protein, MALAT1. If used, few spike-in transcripts may also be present here, though if all of the spike-ins are in the top 50, it suggests that too much spike-in RNA was added. A large number of pseudo-genes or predicted genes may indicate problems with alignment. scater :: plotHighestExprs ( gbm_sce , exprs_values = \"counts\" , n = 30 ) Variable-level metrics are computed by the getVarianceExplained() function (after normalization, see below). This calculates the percentage of variance of each gene\u2019s expression that is explained by each variable in the colData of the SingleCellExperiment object. We can then use this to determine which experimental factors are contributing most to the variance in expression. This is useful for diagnosing batch effects or to quickly verify that a treatment has an effect. First, computing variance explained on the log-counts, so that the statistics reflect changes in relative expression. gbm_sce <- scater :: logNormCounts ( gbm_sce ) # alternative to Seurat's normalization here using scater In the gbm dataset, we only have 1 patient, so we cannot calculate the effect of experimental variables like sex or donor id, but in case we would have several variables, here is the method with the cell cycle phase as example: vars <- scater :: getVarianceExplained ( gbm_sce , variables = \"Phase\" ) head ( vars ) A distribution of percentage variance explained by each gene is shown, and can indicate whether one or the other experimental variable has high contribution to the variance in the data: scater :: plotExplanatoryVariables ( vars ) If we think that the cell cycling has an effect on the analysis, and if we want to \u201cremove\u201d this effect so that cycling cells are integrated into the rest of the cells and not clustering apart anymore, we can regress out the cell cycling phase at the moment of normalizing the data using ScaleData . This might be slow to compute # do not run gbm_cc <- Seurat :: ScaleData ( gbm , vars.to.regress = c ( \"S.Score\" , \"G2M.Score\" ))","title":"Alternative QC exploration using the scater package"},{"location":"day1/quality_control/#save-the-dataset-and-clear-environment","text":"Now, save the dataset so you can use it tomorrow: saveRDS ( gbm , \"gbm_day1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day2/cell_annotation/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation Exercises This chapter uses the gbm dataset Load the gbm dataset you have created earlier today: gbm <- readRDS ( \"gbm_day2_part1.rds\" ) In the last exercise we saw that probably clustering at a resolution of 0.2 gave the most sensible results. Let\u2019s therefore set the default identity of each cell based on this clustering: gbm <- Seurat :: SetIdent ( gbm , value = gbm $ RNA_snn_res.0.2 ) Note From now on, grouping (e.g. for plotting) is done by the active identity (set at @active.ident ) by default. Based on the UMAP we have generated, we can visualize expression for a gene in each cluster: Seurat :: FeaturePlot ( gbm , \"PMP2\" ) Based on expression of sets of genes you can do a manual cell type annotation. If you know the marker genes for some cell types, you can check whether they are up-regulated in one or the other cluster. Here we have some marker genes for two different cell types: immune_genes <- c ( \"GZMA\" , \"CD3E\" , \"CD3D\" ) microglia_genes <- c ( \"CCL4\" , \"CCL3\" , \"P2RY12\" , \"C1QB\" , \"CSF1ER\" , \"CY3CR1\" ) Let\u2019s have a look at the expression of the three immune genes: Seurat :: FeaturePlot ( gbm , immune_genes , ncol = 2 ) These cells are almost all in cluster 6. Which becomes clearer when looking at the violin plot: Seurat :: VlnPlot ( gbm , features = immune_genes ncol = 2 ) Exercise: Have a look at the microglia genes as well. Which cluster contains probably microglial cells? Answer Running Seurat :: FeaturePlot ( gbm , microglia_genes , ncol = 2 ) Returns: Corresponding mainly to cluster 1 (and cluster 4): Seurat :: VlnPlot ( gbm , features = microglia_genes , ncol = 2 ) We can also automate this with the function AddModuleScore . For each cell, an expression score for a group of genes is calcuated: gbm <- Seurat :: AddModuleScore ( gbm , features = list ( immune_genes ), name = \"immune_genes\" ) Exercise: After running AddModuleScore , a column was added to gbm@meta.data . A. What is the name of that column? What kind of data is in there? B. Generate a UMAP with color accoding to this column and a violinplot grouped by cluster. Is this according to what we saw in the previous exercise? Answer A. The new column is called immune_genes1 . It contains the module score for each cell (which is basically the average expression of the set of genes). B. You can plot the UMAP with Seurat :: FeaturePlot ( gbm , \"immune_genes1\" ) Returning: Seurat :: VlnPlot ( gbm , \"immune_genes1\" ) Which indeed shows these genes are mainly expressed in cluster 6: Cell type annotation using SingleR To do a fully automated annoation, we need a reference dataset of primary cells. Any reference could be used. The package scRNAseq in Bioconductor includes several scRNAseq datasets that can be used as reference to SingleR . One could also use a reference made of bulk RNA seq data. Here we are using the Human Primary Cell Atlas dataset from celldex . Check out what\u2019s in there: hpca.se <- celldex :: HumanPrimaryCellAtlasData () class ( hpca.se ) table ( hpca.se $ label.main ) Now SingleR compares our normalized count data to a reference set, and finds the most probable annation: gbm_SingleR <- SingleR :: SingleR ( test = Seurat :: GetAssayData ( gbm , slot = \"data\" ), ref = hpca.se , labels = hpca.se $ label.main ) See what\u2019s in there by using head : head ( gbm_SingleR ) In order to visualize it in our UMAP, we have to add the annotation to gbm@meta.data : gbm $ SingleR_annot <- gbm_SingleR $ labels Seurat :: DimPlot ( gbm , group.by = \"SingleR_annot\" , label = T , repel = T ) Exercise: Compare our manual annotation (based on the set of immune genes) to the annotation with SingleR . Do they correspond? Answer We can have a look at the mean module score for each SingleR annotation like this: mean_scores <- tapply ( gbm $ immune_genes1 , gbm $ SingleR_annot , mean ) mean_scores [order ( mean_scores , decreasing = TRUE ) [1 : 6 ]] Returning: T_cells NK_cell DC Monocyte Macrophage Chondrocytes 1.015605822 0.679592135 0.017018871 -0.005414908 -0.011926460 -0.011975024 Showing that T-cells and NK-cells have a high module score based on our set of immune genes, which makes sense. Of course, it was also already clear from the UMAP plots that cluster 6 (the cluster with the high module score for the immune genes) contained the T-cells and NK-cells. Save the dataset and clear environment Now, save the dataset so you can use it tomorrow: saveRDS ( gbm , \"gbm_day2_part2.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Cell annotation"},{"location":"day2/cell_annotation/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day2/cell_annotation/#material","text":"Download the presentation","title":"Material"},{"location":"day2/cell_annotation/#exercises","text":"This chapter uses the gbm dataset Load the gbm dataset you have created earlier today: gbm <- readRDS ( \"gbm_day2_part1.rds\" ) In the last exercise we saw that probably clustering at a resolution of 0.2 gave the most sensible results. Let\u2019s therefore set the default identity of each cell based on this clustering: gbm <- Seurat :: SetIdent ( gbm , value = gbm $ RNA_snn_res.0.2 ) Note From now on, grouping (e.g. for plotting) is done by the active identity (set at @active.ident ) by default. Based on the UMAP we have generated, we can visualize expression for a gene in each cluster: Seurat :: FeaturePlot ( gbm , \"PMP2\" ) Based on expression of sets of genes you can do a manual cell type annotation. If you know the marker genes for some cell types, you can check whether they are up-regulated in one or the other cluster. Here we have some marker genes for two different cell types: immune_genes <- c ( \"GZMA\" , \"CD3E\" , \"CD3D\" ) microglia_genes <- c ( \"CCL4\" , \"CCL3\" , \"P2RY12\" , \"C1QB\" , \"CSF1ER\" , \"CY3CR1\" ) Let\u2019s have a look at the expression of the three immune genes: Seurat :: FeaturePlot ( gbm , immune_genes , ncol = 2 ) These cells are almost all in cluster 6. Which becomes clearer when looking at the violin plot: Seurat :: VlnPlot ( gbm , features = immune_genes ncol = 2 ) Exercise: Have a look at the microglia genes as well. Which cluster contains probably microglial cells? Answer Running Seurat :: FeaturePlot ( gbm , microglia_genes , ncol = 2 ) Returns: Corresponding mainly to cluster 1 (and cluster 4): Seurat :: VlnPlot ( gbm , features = microglia_genes , ncol = 2 ) We can also automate this with the function AddModuleScore . For each cell, an expression score for a group of genes is calcuated: gbm <- Seurat :: AddModuleScore ( gbm , features = list ( immune_genes ), name = \"immune_genes\" ) Exercise: After running AddModuleScore , a column was added to gbm@meta.data . A. What is the name of that column? What kind of data is in there? B. Generate a UMAP with color accoding to this column and a violinplot grouped by cluster. Is this according to what we saw in the previous exercise? Answer A. The new column is called immune_genes1 . It contains the module score for each cell (which is basically the average expression of the set of genes). B. You can plot the UMAP with Seurat :: FeaturePlot ( gbm , \"immune_genes1\" ) Returning: Seurat :: VlnPlot ( gbm , \"immune_genes1\" ) Which indeed shows these genes are mainly expressed in cluster 6:","title":"Exercises"},{"location":"day2/cell_annotation/#cell-type-annotation-using-singler","text":"To do a fully automated annoation, we need a reference dataset of primary cells. Any reference could be used. The package scRNAseq in Bioconductor includes several scRNAseq datasets that can be used as reference to SingleR . One could also use a reference made of bulk RNA seq data. Here we are using the Human Primary Cell Atlas dataset from celldex . Check out what\u2019s in there: hpca.se <- celldex :: HumanPrimaryCellAtlasData () class ( hpca.se ) table ( hpca.se $ label.main ) Now SingleR compares our normalized count data to a reference set, and finds the most probable annation: gbm_SingleR <- SingleR :: SingleR ( test = Seurat :: GetAssayData ( gbm , slot = \"data\" ), ref = hpca.se , labels = hpca.se $ label.main ) See what\u2019s in there by using head : head ( gbm_SingleR ) In order to visualize it in our UMAP, we have to add the annotation to gbm@meta.data : gbm $ SingleR_annot <- gbm_SingleR $ labels Seurat :: DimPlot ( gbm , group.by = \"SingleR_annot\" , label = T , repel = T ) Exercise: Compare our manual annotation (based on the set of immune genes) to the annotation with SingleR . Do they correspond? Answer We can have a look at the mean module score for each SingleR annotation like this: mean_scores <- tapply ( gbm $ immune_genes1 , gbm $ SingleR_annot , mean ) mean_scores [order ( mean_scores , decreasing = TRUE ) [1 : 6 ]] Returning: T_cells NK_cell DC Monocyte Macrophage Chondrocytes 1.015605822 0.679592135 0.017018871 -0.005414908 -0.011926460 -0.011975024 Showing that T-cells and NK-cells have a high module score based on our set of immune genes, which makes sense. Of course, it was also already clear from the UMAP plots that cluster 6 (the cluster with the high module score for the immune genes) contained the T-cells and NK-cells.","title":"Cell type annotation using SingleR"},{"location":"day2/cell_annotation/#save-the-dataset-and-clear-environment","text":"Now, save the dataset so you can use it tomorrow: saveRDS ( gbm , \"gbm_day2_part2.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day2/dimensionality_reduction/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation Exercises This chapter uses the gbm dataset Dimensionality reduction using Seurat Load the gbm dataset you have created yesterday: gbm <- readRDS ( \"gbm_day1.rds\" ) Once the data is normalized, scaled and variable features have been identified, we can start to reduce the dimensionality of the data. For the PCA, by default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to specify a vector of genes. The PCA will only be run on the variable features, that you can check with VariableFeatures(gbm) . gbm <- Seurat :: RunPCA ( gbm ) To view the PCA plot: Seurat :: DimPlot ( gbm , reduction = \"pca\" ) Coming back to the cell cycle analysis, we can check the distribution of the different cell cycle phases and eventually regress it out using the SCTransform() function. Seurat :: DimPlot ( gbm , reduction = \"pca\" , group.by = \"Phase\" ) Seurat :: DimHeatmap ( gbm , dims = 1 : 12 , cells = 500 , balanced = TRUE ) The elblowplot can help you in determining how many PCs to use for downstream analysis such as UMAP: Seurat :: ElbowPlot ( gbm , ndims = 40 ) The elblow plot ranks principle components based on the percentage of variance explained by each one. Where we observe an \u201celblow\u201d or flattening curve, the majority of true signal is captured by this number of PCs, eg around 25 PCs for the gbm dataset. Including too many PCs usually does not affect much the result, while including too few PCs can affect the results very much. UMAP: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. gbm <- Seurat :: RunUMAP ( gbm , dims = 1 : 25 ) To view the UMAP plot: Seurat :: DimPlot ( gbm , reduction = \"umap\" ) Cells can be colored according to cell cycle phase. Is there a group of cells than contains a high proportion of cells in G2/M phase? Seurat :: DimPlot ( gbm , reduction = \"umap\" , group.by = \"Phase\" ) Clustering The method implemented in Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset. gbm <- Seurat :: FindNeighbors ( gbm , dims = 1 : 25 ) To cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The `FindClusters()`` function implements this procedure, and contains a resolution parameter that sets the \u2018granularity\u2019 of the downstream clustering, with increased values leading to a greater number of clusters. gbm <- Seurat :: FindClusters ( gbm , resolution = seq ( 0.1 , 0.8 , by = 0.1 )) Cluster id of each cell is added to the metadata object, as a new column for each resolution tested: head ( gbm @ meta.data ) To view how clusters sub-divide at increasing resolution: library ( clustree ) clustree :: clustree ( gbm @ meta.data[ , grep ( \"RNA_snn_res\" , colnames ( gbm @ meta.data )) ] , prefix = \"RNA_snn_res.\" ) You can view the UMAP coloring each cell according to a cluster id like this: Seurat :: DimPlot ( gbm , group.by = \"RNA_snn_res.0.1\" ) Exercise: Visualise clustering based on a few more resolutions. Taking the clustering and the UMAP plots into account what do you consider as a good resolution to perform the clustering? Answer Of course, there is no \u2018optimal\u2019 resolution, but based on resolution of 0.2, it seems that clustering fits the UMAP well: Seurat :: DimPlot ( gbm , group.by = \"RNA_snn_res.0.2\" ) Save the dataset and clear environment Now, save the dataset so you can use it later today: saveRDS ( gbm , \"gbm_day2_part1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Dimensionality reduction"},{"location":"day2/dimensionality_reduction/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day2/dimensionality_reduction/#material","text":"Download the presentation","title":"Material"},{"location":"day2/dimensionality_reduction/#exercises","text":"This chapter uses the gbm dataset","title":"Exercises"},{"location":"day2/dimensionality_reduction/#dimensionality-reduction-using-seurat","text":"Load the gbm dataset you have created yesterday: gbm <- readRDS ( \"gbm_day1.rds\" ) Once the data is normalized, scaled and variable features have been identified, we can start to reduce the dimensionality of the data. For the PCA, by default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to specify a vector of genes. The PCA will only be run on the variable features, that you can check with VariableFeatures(gbm) . gbm <- Seurat :: RunPCA ( gbm ) To view the PCA plot: Seurat :: DimPlot ( gbm , reduction = \"pca\" ) Coming back to the cell cycle analysis, we can check the distribution of the different cell cycle phases and eventually regress it out using the SCTransform() function. Seurat :: DimPlot ( gbm , reduction = \"pca\" , group.by = \"Phase\" ) Seurat :: DimHeatmap ( gbm , dims = 1 : 12 , cells = 500 , balanced = TRUE ) The elblowplot can help you in determining how many PCs to use for downstream analysis such as UMAP: Seurat :: ElbowPlot ( gbm , ndims = 40 ) The elblow plot ranks principle components based on the percentage of variance explained by each one. Where we observe an \u201celblow\u201d or flattening curve, the majority of true signal is captured by this number of PCs, eg around 25 PCs for the gbm dataset. Including too many PCs usually does not affect much the result, while including too few PCs can affect the results very much. UMAP: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. gbm <- Seurat :: RunUMAP ( gbm , dims = 1 : 25 ) To view the UMAP plot: Seurat :: DimPlot ( gbm , reduction = \"umap\" ) Cells can be colored according to cell cycle phase. Is there a group of cells than contains a high proportion of cells in G2/M phase? Seurat :: DimPlot ( gbm , reduction = \"umap\" , group.by = \"Phase\" )","title":"Dimensionality reduction using Seurat"},{"location":"day2/dimensionality_reduction/#clustering","text":"The method implemented in Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset. gbm <- Seurat :: FindNeighbors ( gbm , dims = 1 : 25 ) To cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The `FindClusters()`` function implements this procedure, and contains a resolution parameter that sets the \u2018granularity\u2019 of the downstream clustering, with increased values leading to a greater number of clusters. gbm <- Seurat :: FindClusters ( gbm , resolution = seq ( 0.1 , 0.8 , by = 0.1 )) Cluster id of each cell is added to the metadata object, as a new column for each resolution tested: head ( gbm @ meta.data ) To view how clusters sub-divide at increasing resolution: library ( clustree ) clustree :: clustree ( gbm @ meta.data[ , grep ( \"RNA_snn_res\" , colnames ( gbm @ meta.data )) ] , prefix = \"RNA_snn_res.\" ) You can view the UMAP coloring each cell according to a cluster id like this: Seurat :: DimPlot ( gbm , group.by = \"RNA_snn_res.0.1\" ) Exercise: Visualise clustering based on a few more resolutions. Taking the clustering and the UMAP plots into account what do you consider as a good resolution to perform the clustering? Answer Of course, there is no \u2018optimal\u2019 resolution, but based on resolution of 0.2, it seems that clustering fits the UMAP well: Seurat :: DimPlot ( gbm , group.by = \"RNA_snn_res.0.2\" )","title":"Clustering"},{"location":"day2/dimensionality_reduction/#save-the-dataset-and-clear-environment","text":"Now, save the dataset so you can use it later today: saveRDS ( gbm , \"gbm_day2_part1.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day2/integration/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation Exercises This chapter uses the pancreas dataset The gbm dataset does not contain any samples, treatments or methods to integrate. Therefore for these exercises we will use a different dataset that is described in Comprehensive Integration of Single CellData . It is a dataset comprising of four different single cell experiment performed by using four different methods. pancreas.data <- readRDS ( file = \"data/pancreas_dataset/pancreas_expression_matrix.rds\" ) metadata <- readRDS ( file = \"data/pancreas_dataset/pancreas_metadata.rds\" ) Create a Seurat object with all datasets. pancreas <- Seurat :: CreateSeuratObject ( pancreas.data , meta.data = metadata ) The object pancreas is now of class Seurat and comparable with the object gbm that we have used in the previous exercises. Exercise: Have a look at the object. How many cells are in there? And how many features? What kind of information is in the meta.data slot? Answer Just by running pancreas , we get the following information: An object of class Seurat 34363 features across 6321 samples within 1 assay Active assay: RNA (34363 features, 0 variable features) Running head(pancreas@meta.data) gives you: orig.ident nCount_RNA nFeature_RNA tech celltype D101_5 SeuratProject 4615.810 1986 celseq gamma D101_43 SeuratProject 11711.506 3942 celseq gamma D101_93 SeuratProject 5567.659 2418 celseq gamma D102_4 SeuratProject 6804.533 2846 celseq gamma D172444_23 SeuratProject 5541.101 2436 celseq gamma D172444_68 SeuratProject 4301.892 2015 celseq gamma So, apparently there is also information in there about the technology ( tech ) and cell type annotation ( celltype ) Now, we can repeat what we have learned in the previous chapters. Let\u2019s assume we don\u2019t have to filter for e.g. mitochondrial UMIs and number of features, and we can directly proceed to the normalization and scaling. Exercise: To perform normalization, scaling, PCA and UMAP, run the following functions (with sensible parameters) on the pancreas object: Seurat::NormalizeData Seurat::FindVariableFeatures Seurat::ScaleData Seurat::RunPCA Seurat::RunUMAP Answer pancreas <- Seurat :: NormalizeData ( pancreas ) pancreas <- Seurat :: FindVariableFeatures ( pancreas , selection.method = \"vst\" , nfeatures = 2000 ) pancreas <- Seurat :: ScaleData ( pancreas ) pancreas <- Seurat :: RunPCA ( pancreas , npcs = 30 ) pancreas <- Seurat :: RunUMAP ( pancreas , reduction = \"pca\" , dims = 1 : 30 ) Now we plot the UMAP based on technology. There is clearly clustering according to technology: Seurat :: DimPlot ( pancreas , reduction = \"umap\" , group.by = \"tech\" ) Exercise: Generate the same UMAP plot but now grouped by celltype . Does cell type group correctly together? Answer Generate the plot: Seurat :: DimPlot ( pancreas , reduction = \"umap\" , group.by = \"celltype\" ) This returns: This shows that within a techology cell types cluster together, but not between technology (this is e.g. very clear if you look at the clusters annotated as \u201calpha\u201d) To perform the integration, we split the combined object into a list, with each dataset as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation ( \"vst\" ). pancreas.list <- Seurat :: SplitObject ( pancreas , split.by = \"tech\" ) for ( i in 1 : length ( pancreas.list )) { pancreas.list[[i]] <- Seurat :: NormalizeData ( pancreas.list[[i]] ) pancreas.list[[i]] <- Seurat :: FindVariableFeatures ( pancreas.list[[i]] , selection.method = \"vst\" , nfeatures = 2000 , verbose = FALSE ) } After this, we prepare the integration by selecting integration anchors: pancreas.anchors <- Seurat :: FindIntegrationAnchors ( object.list = pancreas.list , dims = 1 : 30 ) And finally perform the integration: pancreas.integrated <- Seurat :: IntegrateData ( anchorset = pancreas.anchors , dims = 1 : 30 ) After running IntegrateData , the Seurat object will contain an additional element of class Assay with the integrated (or \u2018batch-corrected\u2019) expression matrix. This new Assay is called integrated , and exists next to the already existing RNA element with class Assay . Warning Use the Assay integrated only for clustering and visualisation. It will give unexpected results during e.g. differential gene expression analysis. Therefore, use the RNA element for other analyses. We can then use this new integrated matrix for clustering and visualization. Now, we can scale the integrated data, run PCA, and visualize the results with UMAP. Note No need to re-run FindVariableFeatures , these were automatically set by calling IntegrateData . First, switch the default Assay to integrated (in stead of RNA ). Seurat :: DefaultAssay ( pancreas.integrated ) <- \"integrated\" Exercise: In order to redo the clustering, scale the integrated data, run the PCA and the UMAP again (using the function ScaleData , RunPCA and RunUMAP ). After that, generate the same two UMAP plots (grouped by tech and by celltype ). Did the integration perform well? Answer Performing the scaling, PCA and UMAP: pancreas.integrated <- Seurat :: ScaleData ( pancreas.integrated ) pancreas.integrated <- Seurat :: RunPCA ( pancreas.integrated , npcs = 30 ) pancreas.integrated <- Seurat :: RunUMAP ( pancreas.integrated , reduction = \"pca\" , dims = 1 : 30 ) Plotting the UMAP: Seurat :: DimPlot ( pancreas.integrated , reduction = \"umap\" , group.by = \"tech\" ) Seurat :: DimPlot ( pancreas.integrated , reduction = \"umap\" , group.by = \"celltype\" , label = TRUE , repel = TRUE ) Returning: So, yes, integration performed well. Clustering is now not according to technology, but according to cell type. Save the dataset and clear environment Finally, store the integrated dataset as an .rds file. We will use it tomorrow: saveRDS ( pancreas.integrated , \"pancreas.integrated.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Integration"},{"location":"day2/integration/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day2/integration/#material","text":"Download the presentation","title":"Material"},{"location":"day2/integration/#exercises","text":"This chapter uses the pancreas dataset The gbm dataset does not contain any samples, treatments or methods to integrate. Therefore for these exercises we will use a different dataset that is described in Comprehensive Integration of Single CellData . It is a dataset comprising of four different single cell experiment performed by using four different methods. pancreas.data <- readRDS ( file = \"data/pancreas_dataset/pancreas_expression_matrix.rds\" ) metadata <- readRDS ( file = \"data/pancreas_dataset/pancreas_metadata.rds\" ) Create a Seurat object with all datasets. pancreas <- Seurat :: CreateSeuratObject ( pancreas.data , meta.data = metadata ) The object pancreas is now of class Seurat and comparable with the object gbm that we have used in the previous exercises. Exercise: Have a look at the object. How many cells are in there? And how many features? What kind of information is in the meta.data slot? Answer Just by running pancreas , we get the following information: An object of class Seurat 34363 features across 6321 samples within 1 assay Active assay: RNA (34363 features, 0 variable features) Running head(pancreas@meta.data) gives you: orig.ident nCount_RNA nFeature_RNA tech celltype D101_5 SeuratProject 4615.810 1986 celseq gamma D101_43 SeuratProject 11711.506 3942 celseq gamma D101_93 SeuratProject 5567.659 2418 celseq gamma D102_4 SeuratProject 6804.533 2846 celseq gamma D172444_23 SeuratProject 5541.101 2436 celseq gamma D172444_68 SeuratProject 4301.892 2015 celseq gamma So, apparently there is also information in there about the technology ( tech ) and cell type annotation ( celltype ) Now, we can repeat what we have learned in the previous chapters. Let\u2019s assume we don\u2019t have to filter for e.g. mitochondrial UMIs and number of features, and we can directly proceed to the normalization and scaling. Exercise: To perform normalization, scaling, PCA and UMAP, run the following functions (with sensible parameters) on the pancreas object: Seurat::NormalizeData Seurat::FindVariableFeatures Seurat::ScaleData Seurat::RunPCA Seurat::RunUMAP Answer pancreas <- Seurat :: NormalizeData ( pancreas ) pancreas <- Seurat :: FindVariableFeatures ( pancreas , selection.method = \"vst\" , nfeatures = 2000 ) pancreas <- Seurat :: ScaleData ( pancreas ) pancreas <- Seurat :: RunPCA ( pancreas , npcs = 30 ) pancreas <- Seurat :: RunUMAP ( pancreas , reduction = \"pca\" , dims = 1 : 30 ) Now we plot the UMAP based on technology. There is clearly clustering according to technology: Seurat :: DimPlot ( pancreas , reduction = \"umap\" , group.by = \"tech\" ) Exercise: Generate the same UMAP plot but now grouped by celltype . Does cell type group correctly together? Answer Generate the plot: Seurat :: DimPlot ( pancreas , reduction = \"umap\" , group.by = \"celltype\" ) This returns: This shows that within a techology cell types cluster together, but not between technology (this is e.g. very clear if you look at the clusters annotated as \u201calpha\u201d) To perform the integration, we split the combined object into a list, with each dataset as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation ( \"vst\" ). pancreas.list <- Seurat :: SplitObject ( pancreas , split.by = \"tech\" ) for ( i in 1 : length ( pancreas.list )) { pancreas.list[[i]] <- Seurat :: NormalizeData ( pancreas.list[[i]] ) pancreas.list[[i]] <- Seurat :: FindVariableFeatures ( pancreas.list[[i]] , selection.method = \"vst\" , nfeatures = 2000 , verbose = FALSE ) } After this, we prepare the integration by selecting integration anchors: pancreas.anchors <- Seurat :: FindIntegrationAnchors ( object.list = pancreas.list , dims = 1 : 30 ) And finally perform the integration: pancreas.integrated <- Seurat :: IntegrateData ( anchorset = pancreas.anchors , dims = 1 : 30 ) After running IntegrateData , the Seurat object will contain an additional element of class Assay with the integrated (or \u2018batch-corrected\u2019) expression matrix. This new Assay is called integrated , and exists next to the already existing RNA element with class Assay . Warning Use the Assay integrated only for clustering and visualisation. It will give unexpected results during e.g. differential gene expression analysis. Therefore, use the RNA element for other analyses. We can then use this new integrated matrix for clustering and visualization. Now, we can scale the integrated data, run PCA, and visualize the results with UMAP. Note No need to re-run FindVariableFeatures , these were automatically set by calling IntegrateData . First, switch the default Assay to integrated (in stead of RNA ). Seurat :: DefaultAssay ( pancreas.integrated ) <- \"integrated\" Exercise: In order to redo the clustering, scale the integrated data, run the PCA and the UMAP again (using the function ScaleData , RunPCA and RunUMAP ). After that, generate the same two UMAP plots (grouped by tech and by celltype ). Did the integration perform well? Answer Performing the scaling, PCA and UMAP: pancreas.integrated <- Seurat :: ScaleData ( pancreas.integrated ) pancreas.integrated <- Seurat :: RunPCA ( pancreas.integrated , npcs = 30 ) pancreas.integrated <- Seurat :: RunUMAP ( pancreas.integrated , reduction = \"pca\" , dims = 1 : 30 ) Plotting the UMAP: Seurat :: DimPlot ( pancreas.integrated , reduction = \"umap\" , group.by = \"tech\" ) Seurat :: DimPlot ( pancreas.integrated , reduction = \"umap\" , group.by = \"celltype\" , label = TRUE , repel = TRUE ) Returning: So, yes, integration performed well. Clustering is now not according to technology, but according to cell type.","title":"Exercises"},{"location":"day2/integration/#save-the-dataset-and-clear-environment","text":"Finally, store the integrated dataset as an .rds file. We will use it tomorrow: saveRDS ( pancreas.integrated , \"pancreas.integrated.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day3/differential_gene_expression/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation Exercises Find all markers for each cluster This part uses the gbm dataset Load the gbm dataset you have created yesterday: gbm <- readRDS ( \"gbm_day2_part2.rds\" ) The function FindAllMarkers performs a Wilcoxon plot to determine the genes differentially expressed between each cluster and the rest of the cells. Other types of tests than the Wilcoxon test are available. Check it out by running ?Seurat::FindAllMarkers . Now run analysis: de_genes <- Seurat :: FindAllMarkers ( gbm , min.pct = 0.25 ) Time for coffee This takes a while. Have a break. We are usually only interested in significant marker genes, so let\u2019s filter based on an adjusted p-value smaller than 0.05: de_genes <- subset ( de_genes , de_genes $ p_val_adj < 0.05 ) View ( de_genes ) Exercise: What are significant marker genes in cluster 6? Are the immune genes in there? Hint You can re-load the vector with immune genes with: immune_genes <- c ( \"GZMA\" , \"CD3E\" , \"CD3D\" ) Answer Running de_genes[de_genes $ gene %in% immune_genes , ] Returns: p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene GZMA 4.015094e-221 2.441962 0.331 0.005 9.781973e-217 6 GZMA CD3E 0.000000e+00 2.113342 0.474 0.006 0.000000e+00 6 CD3E CD3D 0.000000e+00 2.507228 0.519 0.006 0.000000e+00 6 CD3D So, yes, the immune genes are highly significant markers for cluster 6. Differential expression between clusters This part uses the gbm dataset The FindMarkers function allows to test for differential gene expression analysis specifically between 2 clusters, i.e. perform pairwise comparisons, eg between cells of cluster 0 vs cluster 2, or between cells annotated as astrocytes and macrophages. First we can set the default cell identity to the cell types defined by SingleR : gbm <- Seurat :: SetIdent ( gbm , value = \"SingleR_annot\" ) Run the differential gene expression analysis (runs for a couple of minutes): DEG_astro_vs_macro <- Seurat :: FindMarkers ( gbm , ident.1 = \"Astrocyte\" , ident.2 = \"Macrophage\" , group.by = gbm $ SingleR_annot , test.use = \"wilcox\" ) Exercise: What is the top 10 differentially expressed genes? What does the sign (i.e. positive or negative) mean in the log fold change values? Check your answer by generating a violin plot of a top differentially expressed gene. Answer You can look at the top 10 differentially expressed genes with: top_order <- order ( DEG_astro_vs_macro $ p_val_adj ) DEG_astro_vs_macro[top_order[1 : 10 ] , ] Returning: p_val avg_log2FC pct.1 pct.2 p_val_adj SLC2A5 0 -1.481971 0.080 0.656 0 TNFRSF1B 0 -1.529484 0.041 0.694 0 CAMK2N1 0 2.622397 0.907 0.106 0 C1QA 0 -4.843247 0.088 0.964 0 C1QC 0 -4.374756 0.075 0.943 0 C1QB 0 -4.940663 0.099 0.946 0 LAPTM5 0 -3.685947 0.075 0.987 0 MARCKSL1 0 2.690161 0.911 0.221 0 CNN3 0 2.940659 0.818 0.110 0 CD53 0 -1.861605 0.035 0.804 0 For an explanation of the log fold change have a look at ?Seurat::FindMarkers . At Value it says: avg_logFC : log fold-chage of the average expression between the two groups. Positive values indicate that the gene is more highly expressed in the first group Plotting the top gene SLC2A5 : Seurat :: VlnPlot ( gbm , features = \"SLC2A5\" ) Returning: Differential expression analysis including batch as covariates This part uses the pancreas dataset The Wilcoxon test implemented in FindMarkers does not allow to test for complex design (eg factorial experiments) or to include batch as a covariate. We can use edgeR or limma which are designed for microarray or bulk RNA seq data and provide a design matrix that includes covariates for example. We will go back to the pancreas cells sequenced with different technologies, analyze differentially expressed genes between 2 clusters of cells using the technologies as covariates. Similar approaches can be used to analyze differentially expressed genes between conditions, eg sick vs healthy, wild type versus knockout, etc, and including batches in the model if they are present. We will load the pancreas.integrated object we have created yesterday: pancreas.integrated <- readRDS ( \"pancreas.integrated.rds\" ) Since we will start wit differential gene expression, we set the default assay back to \u201cRNA\u201d. Also, we set the default identity to the cell type: Seurat :: DefaultAssay ( pancreas.integrated ) <- \"RNA\" Seurat :: Idents ( pancreas.integrated ) <- pancreas.integrated $ celltype Let\u2019s have a look at the UMAP (again), coloured by celltype: Seurat :: DimPlot ( pancreas.integrated ) Let\u2019s say we are specifically interested to test for differential gene expression between two cell types. Note Here we could also test for e.g. healthy versus diseased within a celltype/cluster. Now we will run differential expression analysis between cell type delta and gamma using the technology as a covariate by using limma . First, we will subset the pancreas.integrated object, only leaving the delta and gamma cells: pancreas.dg <- subset ( pancreas.integrated , idents = c ( \"delta\" , \"gamma\" )) Get the count matrix and keep only genes that are expressed in at least one cell: counts <- GetAssayData ( pancreas.dg , slot = \"counts\" ) counts <- counts [rowSums ( counts ) != 0 , ] Generate a DGEList object to use as input for limma : dge <- edgeR :: DGEList ( counts = counts ) dge <- edgeR :: calcNormFactors ( dge ) Generate a design matrix: design <- model.matrix ( ~ 0 + celltype + tech , data = pancreas.dg @ meta.data ) colnames ( design ) <- c ( \"delta\" , \"gamma\" , \"celseq2\" , \"fluidigmc1\" , \"smartseq2\" ) Specify which contrasts to check: contrast.mat <- limma :: makeContrasts ( delta - gamma , levels = design ) Now limma can perform the transformation with voom , fit the model, compute the contrasts and compute test statistics with eBayes : vm <- limma :: voom ( dge , design = design , plot = TRUE ) fit <- limma :: lmFit ( vm , design = design ) fit.contrasts <- limma :: contrasts.fit ( fit , contrast.mat ) fit.contrasts <- limma :: eBayes ( fit.contrasts ) We can use topTable to get the most significantly differentially expressed genes: limma :: topTable ( fit.contrasts , number = 10 , sort.by = \"P\" ) And we can check whether this corresponds to the counts by generating a violin plot: VlnPlot ( pancreas.dg , \"PPY\" , split.by = \"tech\" ) VlnPlot ( pancreas.dg , \"RBP4\" , split.by = \"tech\" )","title":"Differential gene expression"},{"location":"day3/differential_gene_expression/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day3/differential_gene_expression/#material","text":"Download the presentation","title":"Material"},{"location":"day3/differential_gene_expression/#exercises","text":"","title":"Exercises"},{"location":"day3/differential_gene_expression/#find-all-markers-for-each-cluster","text":"This part uses the gbm dataset Load the gbm dataset you have created yesterday: gbm <- readRDS ( \"gbm_day2_part2.rds\" ) The function FindAllMarkers performs a Wilcoxon plot to determine the genes differentially expressed between each cluster and the rest of the cells. Other types of tests than the Wilcoxon test are available. Check it out by running ?Seurat::FindAllMarkers . Now run analysis: de_genes <- Seurat :: FindAllMarkers ( gbm , min.pct = 0.25 ) Time for coffee This takes a while. Have a break. We are usually only interested in significant marker genes, so let\u2019s filter based on an adjusted p-value smaller than 0.05: de_genes <- subset ( de_genes , de_genes $ p_val_adj < 0.05 ) View ( de_genes ) Exercise: What are significant marker genes in cluster 6? Are the immune genes in there? Hint You can re-load the vector with immune genes with: immune_genes <- c ( \"GZMA\" , \"CD3E\" , \"CD3D\" ) Answer Running de_genes[de_genes $ gene %in% immune_genes , ] Returns: p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene GZMA 4.015094e-221 2.441962 0.331 0.005 9.781973e-217 6 GZMA CD3E 0.000000e+00 2.113342 0.474 0.006 0.000000e+00 6 CD3E CD3D 0.000000e+00 2.507228 0.519 0.006 0.000000e+00 6 CD3D So, yes, the immune genes are highly significant markers for cluster 6.","title":"Find all markers for each cluster"},{"location":"day3/differential_gene_expression/#differential-expression-between-clusters","text":"This part uses the gbm dataset The FindMarkers function allows to test for differential gene expression analysis specifically between 2 clusters, i.e. perform pairwise comparisons, eg between cells of cluster 0 vs cluster 2, or between cells annotated as astrocytes and macrophages. First we can set the default cell identity to the cell types defined by SingleR : gbm <- Seurat :: SetIdent ( gbm , value = \"SingleR_annot\" ) Run the differential gene expression analysis (runs for a couple of minutes): DEG_astro_vs_macro <- Seurat :: FindMarkers ( gbm , ident.1 = \"Astrocyte\" , ident.2 = \"Macrophage\" , group.by = gbm $ SingleR_annot , test.use = \"wilcox\" ) Exercise: What is the top 10 differentially expressed genes? What does the sign (i.e. positive or negative) mean in the log fold change values? Check your answer by generating a violin plot of a top differentially expressed gene. Answer You can look at the top 10 differentially expressed genes with: top_order <- order ( DEG_astro_vs_macro $ p_val_adj ) DEG_astro_vs_macro[top_order[1 : 10 ] , ] Returning: p_val avg_log2FC pct.1 pct.2 p_val_adj SLC2A5 0 -1.481971 0.080 0.656 0 TNFRSF1B 0 -1.529484 0.041 0.694 0 CAMK2N1 0 2.622397 0.907 0.106 0 C1QA 0 -4.843247 0.088 0.964 0 C1QC 0 -4.374756 0.075 0.943 0 C1QB 0 -4.940663 0.099 0.946 0 LAPTM5 0 -3.685947 0.075 0.987 0 MARCKSL1 0 2.690161 0.911 0.221 0 CNN3 0 2.940659 0.818 0.110 0 CD53 0 -1.861605 0.035 0.804 0 For an explanation of the log fold change have a look at ?Seurat::FindMarkers . At Value it says: avg_logFC : log fold-chage of the average expression between the two groups. Positive values indicate that the gene is more highly expressed in the first group Plotting the top gene SLC2A5 : Seurat :: VlnPlot ( gbm , features = \"SLC2A5\" ) Returning:","title":"Differential expression between clusters"},{"location":"day3/differential_gene_expression/#differential-expression-analysis-including-batch-as-covariates","text":"This part uses the pancreas dataset The Wilcoxon test implemented in FindMarkers does not allow to test for complex design (eg factorial experiments) or to include batch as a covariate. We can use edgeR or limma which are designed for microarray or bulk RNA seq data and provide a design matrix that includes covariates for example. We will go back to the pancreas cells sequenced with different technologies, analyze differentially expressed genes between 2 clusters of cells using the technologies as covariates. Similar approaches can be used to analyze differentially expressed genes between conditions, eg sick vs healthy, wild type versus knockout, etc, and including batches in the model if they are present. We will load the pancreas.integrated object we have created yesterday: pancreas.integrated <- readRDS ( \"pancreas.integrated.rds\" ) Since we will start wit differential gene expression, we set the default assay back to \u201cRNA\u201d. Also, we set the default identity to the cell type: Seurat :: DefaultAssay ( pancreas.integrated ) <- \"RNA\" Seurat :: Idents ( pancreas.integrated ) <- pancreas.integrated $ celltype Let\u2019s have a look at the UMAP (again), coloured by celltype: Seurat :: DimPlot ( pancreas.integrated ) Let\u2019s say we are specifically interested to test for differential gene expression between two cell types. Note Here we could also test for e.g. healthy versus diseased within a celltype/cluster. Now we will run differential expression analysis between cell type delta and gamma using the technology as a covariate by using limma . First, we will subset the pancreas.integrated object, only leaving the delta and gamma cells: pancreas.dg <- subset ( pancreas.integrated , idents = c ( \"delta\" , \"gamma\" )) Get the count matrix and keep only genes that are expressed in at least one cell: counts <- GetAssayData ( pancreas.dg , slot = \"counts\" ) counts <- counts [rowSums ( counts ) != 0 , ] Generate a DGEList object to use as input for limma : dge <- edgeR :: DGEList ( counts = counts ) dge <- edgeR :: calcNormFactors ( dge ) Generate a design matrix: design <- model.matrix ( ~ 0 + celltype + tech , data = pancreas.dg @ meta.data ) colnames ( design ) <- c ( \"delta\" , \"gamma\" , \"celseq2\" , \"fluidigmc1\" , \"smartseq2\" ) Specify which contrasts to check: contrast.mat <- limma :: makeContrasts ( delta - gamma , levels = design ) Now limma can perform the transformation with voom , fit the model, compute the contrasts and compute test statistics with eBayes : vm <- limma :: voom ( dge , design = design , plot = TRUE ) fit <- limma :: lmFit ( vm , design = design ) fit.contrasts <- limma :: contrasts.fit ( fit , contrast.mat ) fit.contrasts <- limma :: eBayes ( fit.contrasts ) We can use topTable to get the most significantly differentially expressed genes: limma :: topTable ( fit.contrasts , number = 10 , sort.by = \"P\" ) And we can check whether this corresponds to the counts by generating a violin plot: VlnPlot ( pancreas.dg , \"PPY\" , split.by = \"tech\" ) VlnPlot ( pancreas.dg , \"RBP4\" , split.by = \"tech\" )","title":"Differential expression analysis including batch as covariates"},{"location":"day3/enrichment_analysis/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation MSigDB clusterProfiler vignette Exercises This chapter uses the gbm dataset If the FindMarkers or FindAllMarkers functions were used, we have a table containing only the significant genes, but we don\u2019t have any information for the non-significant genes. Therefore, we can use the over-representation analysis which is a threshold-based method. Using our list of significant genes, we can test if any gene set is over-represented in our data or not using a test similar to a Fisher test to compare differences in proportions. The clusterProfiler package provides functions for over-representation analysis of Gene Ontology gene sets (among other functions) or KEGG gene sets. Genes can be labeled using different types of labels, eg symbol, ensembl ID, Entrez ID. To list the allowed label types use: BiocManager :: install ( \"org.Hs.eg.db\" ) library ( org.Hs.eg.db ) AnnotationDbi :: keytypes ( org.Hs.eg.db ) Let\u2019s select a set of genes that are upregulated in the astrocytes compared to the macrophages: AC_up_DEG <- subset ( DEG_astro_vs_macro , DEG_astro_vs_macro $ avg_log2FC > 0 & DEG_astro_vs_macro $ p_val_adj < 0.05 ) AC_up_genes <- rownames ( AC_up_DEG ) We can do a gene ontology term enrichment analysis based on this set of genes: AC_MAC_GO <- clusterProfiler :: enrichGO ( AC_up_genes , # vector of up regulated genes \"org.Hs.eg.db\" , # orgdb= package that contains gene label types correspondances keyType = \"SYMBOL\" , # indicate that genes are labeled using symbols ont = \"BP\" , # which of the GO categories to test, here the \"Biological Processes\" minGSSize = 50 ) # exclude gene sets that contain less than 50 genes The results are stored in the @result slot: View ( AC_MAC_GO @ result ) We can quite easily generate an enrichment map with the enrichplot package: enrichplot :: emapplot ( enrichplot :: pairwise_termsim ( AC_MAC_GO ), showCategory = 30 ) In stead of testing for gene ontology terms, we can also test for other gene set collections. For example the hallmark collection from MSigDB : gmt <- clusterProfiler :: read.gmt ( \"data/h.all.v7.2.symbols.xls\" ) head ( gmt ) We can use the function enricher to test for enrichment of any set of genes. But we would have to test it against a \u201cuniverse\u201d, i.e. the background genes: AC_MAC_enrich <- clusterProfiler :: enricher ( gene = AC_up_genes , universe = rownames ( gbm ), pAdjustMethod = \"BH\" , pvalueCutoff = 0.05 , qvalueCutoff = 0.05 , TERM2GENE = gmt ) The most signifcantly enriched group of genes is HALLMARK_MYC_TARGETS_V1 : View ( AC_MAC_enrich @ result ) You can get a vector of gene symbols that are in the set of MYC targets like this: myc_target_genes <- gmt $ gene[gmt $ term == \"HALLMARK_MYC_TARGETS_V1\" ) ] Exercise: Calculate a module score for each cell for the MYC target genes by using the function AddModuleScore , and generate a violin plot of the gbm dataset to view differences of this score between SingleR annotations. Answer Generating module scores: gbm <- Seurat :: AddModuleScore ( gbm , features = list ( myc_target_genes = myc_target_genes ), name = \"myc_target_genes\" ) Generate violing plot. Note that the scores generated by AddModuleScore are stored in gbm$my_target_genes1 : VlnPlot ( gbm , \"myc_target_genes1\" , group.by = \"SingleR_annot\" ) Returning: Showing that the score is on average higher in the cells annotated as astrocyte compared to cells annotated as macrophage. Save the dataset and clear environment Now, save the dataset so you can use it later today: saveRDS ( gbm , \"gbm_day3.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Erichment analysis"},{"location":"day3/enrichment_analysis/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day3/enrichment_analysis/#material","text":"Download the presentation MSigDB clusterProfiler vignette","title":"Material"},{"location":"day3/enrichment_analysis/#exercises","text":"This chapter uses the gbm dataset If the FindMarkers or FindAllMarkers functions were used, we have a table containing only the significant genes, but we don\u2019t have any information for the non-significant genes. Therefore, we can use the over-representation analysis which is a threshold-based method. Using our list of significant genes, we can test if any gene set is over-represented in our data or not using a test similar to a Fisher test to compare differences in proportions. The clusterProfiler package provides functions for over-representation analysis of Gene Ontology gene sets (among other functions) or KEGG gene sets. Genes can be labeled using different types of labels, eg symbol, ensembl ID, Entrez ID. To list the allowed label types use: BiocManager :: install ( \"org.Hs.eg.db\" ) library ( org.Hs.eg.db ) AnnotationDbi :: keytypes ( org.Hs.eg.db ) Let\u2019s select a set of genes that are upregulated in the astrocytes compared to the macrophages: AC_up_DEG <- subset ( DEG_astro_vs_macro , DEG_astro_vs_macro $ avg_log2FC > 0 & DEG_astro_vs_macro $ p_val_adj < 0.05 ) AC_up_genes <- rownames ( AC_up_DEG ) We can do a gene ontology term enrichment analysis based on this set of genes: AC_MAC_GO <- clusterProfiler :: enrichGO ( AC_up_genes , # vector of up regulated genes \"org.Hs.eg.db\" , # orgdb= package that contains gene label types correspondances keyType = \"SYMBOL\" , # indicate that genes are labeled using symbols ont = \"BP\" , # which of the GO categories to test, here the \"Biological Processes\" minGSSize = 50 ) # exclude gene sets that contain less than 50 genes The results are stored in the @result slot: View ( AC_MAC_GO @ result ) We can quite easily generate an enrichment map with the enrichplot package: enrichplot :: emapplot ( enrichplot :: pairwise_termsim ( AC_MAC_GO ), showCategory = 30 ) In stead of testing for gene ontology terms, we can also test for other gene set collections. For example the hallmark collection from MSigDB : gmt <- clusterProfiler :: read.gmt ( \"data/h.all.v7.2.symbols.xls\" ) head ( gmt ) We can use the function enricher to test for enrichment of any set of genes. But we would have to test it against a \u201cuniverse\u201d, i.e. the background genes: AC_MAC_enrich <- clusterProfiler :: enricher ( gene = AC_up_genes , universe = rownames ( gbm ), pAdjustMethod = \"BH\" , pvalueCutoff = 0.05 , qvalueCutoff = 0.05 , TERM2GENE = gmt ) The most signifcantly enriched group of genes is HALLMARK_MYC_TARGETS_V1 : View ( AC_MAC_enrich @ result ) You can get a vector of gene symbols that are in the set of MYC targets like this: myc_target_genes <- gmt $ gene[gmt $ term == \"HALLMARK_MYC_TARGETS_V1\" ) ] Exercise: Calculate a module score for each cell for the MYC target genes by using the function AddModuleScore , and generate a violin plot of the gbm dataset to view differences of this score between SingleR annotations. Answer Generating module scores: gbm <- Seurat :: AddModuleScore ( gbm , features = list ( myc_target_genes = myc_target_genes ), name = \"myc_target_genes\" ) Generate violing plot. Note that the scores generated by AddModuleScore are stored in gbm$my_target_genes1 : VlnPlot ( gbm , \"myc_target_genes1\" , group.by = \"SingleR_annot\" ) Returning: Showing that the score is on average higher in the cells annotated as astrocyte compared to cells annotated as macrophage.","title":"Exercises"},{"location":"day3/enrichment_analysis/#save-the-dataset-and-clear-environment","text":"Now, save the dataset so you can use it later today: saveRDS ( gbm , \"gbm_day3.rds\" ) Clear your environment: rm ( list = ls ()) gc () .rs.restartR ()","title":"Save the dataset and clear environment"},{"location":"day3/trajectory_analysis/","text":"Learning outcomes After having completed this chapter you will be able to: Material Download the presentation slingshot vignette Exercises Trajectory analysis using Slingshot This part uses the Deng dataset Bug Paper citation needed Read in data. It is an object of class SingleCellExperiment . deng_SCE <- readRDS ( \"data/deng_dataset/deng-reads.rds\" ) Perform the first steps of the analysis. The deng_SCE object contains cells that were isolated at different stages of mouse embryogenesis, from the zygote stage to the late blastula. The levels of the cell type are in alphabetical order. We now change the level order for plotting in developmental order: deng_SCE $ cell_type2 <- factor ( deng_SCE $ cell_type2 , levels = c ( \"zy\" , \"early2cell\" , \"mid2cell\" , \"late2cell\" , \"4cell\" , \"8cell\" , \"16cell\" , \"earlyblast\" , \"midblast\" , \"lateblast\" )) We can run a PCA directly on the object of class SingleCellExperiment with the function runPCA : deng_SCE <- BiocSingular :: runPCA ( deng_SCE , ncomponents = 50 ) Read the Slingshot documentation ( ?slingshot::slingshot ) and then run Slingshot below. sce <- slingshot :: slingshot ( deng_SCE , reducedDim = 'PCA' ) Exercise: Given your understanding of the algorithm and the documentation, what is one major set of parameters we omitted here when running Slingshot? Answer We didn\u2019t set the parameter clusterLabels Here is a custom function to plot the PCA based on a slingshot object. Run it in the console to add it to your global environment: PCAplot_slingshot <- function ( sce , draw_lines = TRUE , variable = NULL , legend = FALSE , ... ){ # set palette for factorial variables palf <- colorRampPalette ( RColorBrewer :: brewer.pal ( 8 , \"Set2\" )) # set palette for numeric variables paln <- colorRampPalette ( RColorBrewer :: brewer.pal ( 9 , \"Blues\" )) # extract pca from SingleCellExperiment object pca <- SingleCellExperiment :: reducedDims ( sce ) $ PCA if ( is.null ( variable )){ col <- \"black\" } if ( is.character ( variable )){ variable <- as.factor ( variable ) } if ( is.factor ( variable )){ colpal <- palf ( length ( levels ( variable ))) colors <- colpal[variable] } if ( is.numeric ( variable )){ colpal <- paln ( 50 ) colors <- colpal [cut ( variable , breaks = 50 ) ] } # draw the plot plot ( pca , bg = colors , pch = 21 ) # draw lines if ( draw_lines ){ slingshot :: lines ( slingshot :: SlingshotDataSet ( sce ), lwd = 2 , ... ) } # add legend if ( legend & is.factor ( variable )){ legend ( \"bottomright\" , pt.bg = colpal , legend = levels ( variable ), pch = 21 ) } } Have a look at the PCA with the slingshot pseudotime line: PCAplot_slingshot ( sce , variable = sce $ slingPseudotime_1 , draw_lines = TRUE ) Also have a look at pseudotime versus cell type: ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = sce $ slingPseudotime_1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) This already looks pretty good. Let\u2019s see whether we can improve it. First we generate clusters by using Seurat : gcdata <- Seurat :: CreateSeuratObject ( counts = SingleCellExperiment :: counts ( deng_SCE ), project = \"slingshot\" ) gcdata <- Seurat :: NormalizeData ( object = gcdata , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) gcdata <- Seurat :: FindVariableFeatures ( object = gcdata , mean.function = ExpMean , dispersion.function = LogVMR ) gcdata <- Seurat :: ScaleData ( object = gcdata , do.center = T , do.scale = F ) gcdata <- Seurat :: RunPCA ( object = gcdata , pc.genes = gcdata @ var.genes ) gcdata <- Seurat :: FindNeighbors ( gcdata , dims = 1 : 5 ) # clustering with resolution of 0.6 gcdata <- Seurat :: FindClusters ( object = gcdata , resolution = 0.6 ) Exercise: Have a look at the UMAP and color it according to the clustering (we used a resolution of 0.6). Does it look acceptable to you? Note The UMAP has not yet been generated for this object. Answer First run the UMAP and after that generate the plot: gcdata <- Seurat :: RunUMAP ( gcdata , dims = 1 : 5 ) Seurat :: DimPlot ( gcdata ) Returns: Now we can add these clusters to the slingshot function: deng_SCE $ Seurat_clusters <- as.character ( Idents ( gcdata )) # go from factor to character deng_SCE <- slingshot :: slingshot ( deng_SCE , clusterLabels = 'Seurat_clusters' , reducedDim = 'PCA' ) There have been added two slingPseudotime columns: head ( colData ( deng_SCE )) Let\u2019s see whether things have improved: PCAplot_slingshot ( deng_SCE , variable = deng_SCE $ slingPseudotime_2 ) ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = slingPseudotime_2 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) Particularly the later stages, separation seems to improve. Since we have included the Seurat clustering, we can plot the PCA, with colors according to these clusters: PCAplot_slingshot ( deng_SCE , variable = deng_SCE $ Seurat_clusters , type = 'lineages' , col = 'black' , legend = TRUE ) PCAplot_slingshot ( deng_SCE , variable = deng_SCE $ cell_type2 , type = 'lineages' , col = 'black' , legend = TRUE )","title":"Trajectory analysis"},{"location":"day3/trajectory_analysis/#learning-outcomes","text":"After having completed this chapter you will be able to:","title":"Learning outcomes"},{"location":"day3/trajectory_analysis/#material","text":"Download the presentation slingshot vignette","title":"Material"},{"location":"day3/trajectory_analysis/#exercises","text":"","title":"Exercises"},{"location":"day3/trajectory_analysis/#trajectory-analysis-using-slingshot","text":"This part uses the Deng dataset Bug Paper citation needed Read in data. It is an object of class SingleCellExperiment . deng_SCE <- readRDS ( \"data/deng_dataset/deng-reads.rds\" ) Perform the first steps of the analysis. The deng_SCE object contains cells that were isolated at different stages of mouse embryogenesis, from the zygote stage to the late blastula. The levels of the cell type are in alphabetical order. We now change the level order for plotting in developmental order: deng_SCE $ cell_type2 <- factor ( deng_SCE $ cell_type2 , levels = c ( \"zy\" , \"early2cell\" , \"mid2cell\" , \"late2cell\" , \"4cell\" , \"8cell\" , \"16cell\" , \"earlyblast\" , \"midblast\" , \"lateblast\" )) We can run a PCA directly on the object of class SingleCellExperiment with the function runPCA : deng_SCE <- BiocSingular :: runPCA ( deng_SCE , ncomponents = 50 ) Read the Slingshot documentation ( ?slingshot::slingshot ) and then run Slingshot below. sce <- slingshot :: slingshot ( deng_SCE , reducedDim = 'PCA' ) Exercise: Given your understanding of the algorithm and the documentation, what is one major set of parameters we omitted here when running Slingshot? Answer We didn\u2019t set the parameter clusterLabels Here is a custom function to plot the PCA based on a slingshot object. Run it in the console to add it to your global environment: PCAplot_slingshot <- function ( sce , draw_lines = TRUE , variable = NULL , legend = FALSE , ... ){ # set palette for factorial variables palf <- colorRampPalette ( RColorBrewer :: brewer.pal ( 8 , \"Set2\" )) # set palette for numeric variables paln <- colorRampPalette ( RColorBrewer :: brewer.pal ( 9 , \"Blues\" )) # extract pca from SingleCellExperiment object pca <- SingleCellExperiment :: reducedDims ( sce ) $ PCA if ( is.null ( variable )){ col <- \"black\" } if ( is.character ( variable )){ variable <- as.factor ( variable ) } if ( is.factor ( variable )){ colpal <- palf ( length ( levels ( variable ))) colors <- colpal[variable] } if ( is.numeric ( variable )){ colpal <- paln ( 50 ) colors <- colpal [cut ( variable , breaks = 50 ) ] } # draw the plot plot ( pca , bg = colors , pch = 21 ) # draw lines if ( draw_lines ){ slingshot :: lines ( slingshot :: SlingshotDataSet ( sce ), lwd = 2 , ... ) } # add legend if ( legend & is.factor ( variable )){ legend ( \"bottomright\" , pt.bg = colpal , legend = levels ( variable ), pch = 21 ) } } Have a look at the PCA with the slingshot pseudotime line: PCAplot_slingshot ( sce , variable = sce $ slingPseudotime_1 , draw_lines = TRUE ) Also have a look at pseudotime versus cell type: ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = sce $ slingPseudotime_1 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) This already looks pretty good. Let\u2019s see whether we can improve it. First we generate clusters by using Seurat : gcdata <- Seurat :: CreateSeuratObject ( counts = SingleCellExperiment :: counts ( deng_SCE ), project = \"slingshot\" ) gcdata <- Seurat :: NormalizeData ( object = gcdata , normalization.method = \"LogNormalize\" , scale.factor = 10000 ) gcdata <- Seurat :: FindVariableFeatures ( object = gcdata , mean.function = ExpMean , dispersion.function = LogVMR ) gcdata <- Seurat :: ScaleData ( object = gcdata , do.center = T , do.scale = F ) gcdata <- Seurat :: RunPCA ( object = gcdata , pc.genes = gcdata @ var.genes ) gcdata <- Seurat :: FindNeighbors ( gcdata , dims = 1 : 5 ) # clustering with resolution of 0.6 gcdata <- Seurat :: FindClusters ( object = gcdata , resolution = 0.6 ) Exercise: Have a look at the UMAP and color it according to the clustering (we used a resolution of 0.6). Does it look acceptable to you? Note The UMAP has not yet been generated for this object. Answer First run the UMAP and after that generate the plot: gcdata <- Seurat :: RunUMAP ( gcdata , dims = 1 : 5 ) Seurat :: DimPlot ( gcdata ) Returns: Now we can add these clusters to the slingshot function: deng_SCE $ Seurat_clusters <- as.character ( Idents ( gcdata )) # go from factor to character deng_SCE <- slingshot :: slingshot ( deng_SCE , clusterLabels = 'Seurat_clusters' , reducedDim = 'PCA' ) There have been added two slingPseudotime columns: head ( colData ( deng_SCE )) Let\u2019s see whether things have improved: PCAplot_slingshot ( deng_SCE , variable = deng_SCE $ slingPseudotime_2 ) ggplot ( as.data.frame ( colData ( deng_SCE )), aes ( x = slingPseudotime_2 , y = cell_type2 , colour = cell_type2 )) + ggbeeswarm :: geom_quasirandom ( groupOnX = FALSE ) + theme_classic () + xlab ( \"Slingshot pseudotime\" ) + ylab ( \"Timepoint\" ) + ggtitle ( \"Cells ordered by Slingshot pseudotime\" ) Particularly the later stages, separation seems to improve. Since we have included the Seurat clustering, we can plot the PCA, with colors according to these clusters: PCAplot_slingshot ( deng_SCE , variable = deng_SCE $ Seurat_clusters , type = 'lineages' , col = 'black' , legend = TRUE ) PCAplot_slingshot ( deng_SCE , variable = deng_SCE $ cell_type2 , type = 'lineages' , col = 'black' , legend = TRUE )","title":"Trajectory analysis using Slingshot"}]}